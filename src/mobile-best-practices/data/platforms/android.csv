Category,Guideline,Description,Do,Dont,Code Good,Code Bad,Severity,Docs URL
Compose,State Hoisting,Hoist state to caller for reusable composables,Hoist state to caller pass via parameters,Put state inside low-level composables,"fun Counter(count: Int onIncrement: () -> Unit)","fun Counter() { var count by remember { mutableStateOf(0) } }",High,https://developer.android.com/develop/ui/compose/state#state-hoisting
Compose,rememberSaveable,Use rememberSaveable to survive config changes,rememberSaveable for user input and visible state,remember for state that must survive rotation,"val text by rememberSaveable { mutableStateOf("""") }","val text by remember { mutableStateOf("""") }",High,https://developer.android.com/develop/ui/compose/state#restore-ui-state
Compose,LazyColumn Keys,Always provide stable keys for LazyColumn items,Use unique ID from data model as key,Use index or no key,"LazyColumn { items(list key = { it.id }) { } }","LazyColumn { items(list) { } }",High,https://developer.android.com/develop/ui/compose/lists#item-keys
Compose,Stable Annotations,Mark classes @Stable or @Immutable for skip optimization,Use @Immutable for truly immutable data classes,Pass mutable classes to composables,"@Immutable data class UiState(val items: ImmutableList<Item>)","data class UiState(val items: List<Item>) // unstable",Medium,https://developer.android.com/develop/ui/compose/performance/stability
Compose,derivedStateOf,Use derivedStateOf for computed values from other states,Wrap expensive computations depending on state,Compute in composition on every recomposition,"val filtered by remember { derivedStateOf { list.filter { it.active } } }","val filtered = list.filter { it.active } // recomputes every recomposition",Medium,https://developer.android.com/develop/ui/compose/side-effects#derivedstateof
Compose,Modifier Order,Modifier order matters - applied outside-in,Apply clickable before padding for larger touch target,Random modifier ordering,"Modifier.clickable { }.padding(16.dp)","Modifier.padding(16.dp).clickable { } // small touch target",Medium,https://developer.android.com/develop/ui/compose/modifiers#order-matters
Compose,Side Effects,Use LaunchedEffect/DisposableEffect for side effects,LaunchedEffect for coroutines DisposableEffect for cleanup,Launch coroutines in composition directly,"LaunchedEffect(key) { viewModel.load() }","rememberCoroutineScope().launch { } // in composition",High,https://developer.android.com/develop/ui/compose/side-effects
Compose,CompositionLocal,Use CompositionLocal sparingly for implicit data,Use for theme-level or widely-used dependencies,Use for passing regular business data,"val LocalAnalytics = staticCompositionLocalOf<Analytics> { error('') }","CompositionLocal for every dependency",Low,https://developer.android.com/develop/ui/compose/compositionlocal
Compose,Slot APIs,Use slot APIs (content lambdas) for flexible composables,Accept @Composable content parameters,Hardcode composable content,"fun Card(content: @Composable () -> Unit) { Surface { content() } }","fun Card(title: String body: String) // inflexible",Medium,https://developer.android.com/develop/ui/compose/layouts/basics
Compose,Preview,Write Compose previews for rapid iteration,Create previews with different states and themes,Skip previews for composables,"@Preview @Composable fun MyScreenPreview() { MyScreen(UiState.Success(mock)) }","No previews only test on device",Low,https://developer.android.com/develop/ui/compose/tooling/previews
Architecture,ViewModel Scope,Use viewModelScope for coroutines in ViewModel,Launch in viewModelScope auto-cancelled on clear,Create custom CoroutineScope in ViewModel,"viewModelScope.launch { repo.fetchData() }","CoroutineScope(Dispatchers.Main) // not cancelled",High,https://developer.android.com/topic/libraries/architecture/viewmodel
Architecture,StateFlow over LiveData,Prefer StateFlow over LiveData in new code,Use StateFlow with collectAsStateWithLifecycle,Use LiveData in Compose projects,"val state: StateFlow<UiState> = _state.asStateFlow()","val state: LiveData<UiState> = _state",Medium,https://developer.android.com/kotlin/flow/stateflow-and-sharedflow
Architecture,Single Activity,Use single Activity with Navigation Compose,One Activity multiple composable destinations,Multiple Activities for each screen,"NavHost(navController startDest = 'home') { composable('home') {} }","startActivity(Intent(this DetailActivity::class.java))",Medium,https://developer.android.com/guide/navigation/get-started
Architecture,Hilt ViewModel Injection,Inject dependencies into ViewModel via Hilt,Use @HiltViewModel with @Inject constructor,Create ViewModel with manual factory,"@HiltViewModel class MyVM @Inject constructor(val repo: Repo) : ViewModel()","class MyVM : ViewModel() { val repo = Repo(ApiService()) }",High,https://developer.android.com/training/dependency-injection/hilt-android
Architecture,Repository Pattern,Abstract data sources behind Repository interface,Repository mediates between data sources and domain,ViewModel directly calls API or database,"class UserRepo(val api: Api val db: Db) { suspend fun getUser(id) = db.get(id) ?: api.fetch(id) }","class MyVM { val data = Retrofit.create(Api::class).getData() }",High,https://developer.android.com/topic/architecture/data-layer
Architecture,Sealed Interface for State,Use sealed interface for UI state modeling,Represent all possible states explicitly,Use nullable booleans for state,"sealed interface UiState { data object Loading; data class Success(val data: List<Item>); data class Error(val msg: String) }","data class UiState(val data: List<Item>? val loading: Boolean val error: String?)",High,
Architecture,SavedStateHandle,Use SavedStateHandle for process death survival,Save minimal UI state in SavedStateHandle,Rely only on ViewModel surviving,class MyVM(saved: SavedStateHandle) { val query = saved.getStateFlow('query' '') },class MyVM { var query = '' } // lost on process death,Medium,https://developer.android.com/topic/libraries/architecture/viewmodel/viewmodel-savedstate
Architecture,Multi-Module Structure,Organize large projects into feature modules,feature/ core/ app/ modules with clear boundaries,Single monolithic app module,"feature-home/ feature-auth/ core-network/ core-database/ app/","app/src/main/java/com/myapp/everything/",Medium,https://developer.android.com/topic/modularization
Coroutines,Dispatchers Usage,Use correct dispatcher for the work type,IO for network/disk Main for UI Default for CPU,Use Dispatchers.Main for everything,"withContext(Dispatchers.IO) { repo.fetchData() }","GlobalScope.launch(Dispatchers.Main) { api.fetch() }",High,https://developer.android.com/kotlin/coroutines/coroutines-best-practices
Coroutines,Structured Concurrency,Use structured concurrency never GlobalScope,Use viewModelScope lifecycleScope or coroutineScope,Use GlobalScope for fire-and-forget,"viewModelScope.launch { loadData() }","GlobalScope.launch { loadData() } // leaks",Critical,https://developer.android.com/kotlin/coroutines/coroutines-best-practices
Coroutines,Exception Handling,Handle coroutine exceptions properly,Use try-catch or CoroutineExceptionHandler,Let exceptions crash silently,"try { api.fetch() } catch (e: Exception) { emit(Error(e.message)) }","launch { api.fetch() } // exception swallowed",High,
Coroutines,Flow Collection,Collect Flow lifecycle-aware in Compose,Use collectAsStateWithLifecycle,Use collectAsState without lifecycle,"val state by viewModel.state.collectAsStateWithLifecycle()","val state by viewModel.state.collectAsState() // collects invisible",High,https://developer.android.com/kotlin/flow/stateflow-and-sharedflow
Coroutines,Cancellation,Respect coroutine cancellation properly,Check isActive use ensureActive() in loops,Ignore cancellation in long work,"while (isActive) { processNextItem() }","while (true) { processNextItem() } // not cancellable",Medium,
Lifecycle,Lifecycle-aware Collection,Collect flows respecting lifecycle,Use repeatOnLifecycle or flowWithLifecycle,Collect in onCreate without lifecycle,"lifecycleScope.launch { repeatOnLifecycle(STARTED) { flow.collect {} } }","lifecycleScope.launch { flow.collect {} } // background",Critical,https://developer.android.com/topic/libraries/architecture/coroutines
Lifecycle,Configuration Change,Handle configuration changes properly,Use ViewModel + rememberSaveable,Manually handle configChanges in manifest,"ViewModel survives; rememberSaveable for UI state","android:configChanges='orientation' // blocks handling",High,https://developer.android.com/guide/topics/resources/runtime-changes
Lifecycle,Process Death,Handle process death restoration,Save state in SavedStateHandle and restore,Assume ViewModel always survives,"SavedStateHandle for nav args and transient state","Only ViewModel without SavedStateHandle",Medium,https://developer.android.com/topic/libraries/architecture/saving-states
Lifecycle,onCleared Cleanup,Clean up resources in ViewModel onCleared,Cancel jobs close connections in onCleared,Let resources leak after ViewModel destroyed,"override fun onCleared() { connection.close() }","No cleanup in onCleared",High,
Lifecycle,BackHandler,Handle predictive back gesture properly,Use BackHandler composable for custom back,Override onBackPressed in Activity,"BackHandler(enabled = showDialog) { showDialog = false }","override fun onBackPressed() {} // deprecated",Medium,https://developer.android.com/develop/ui/views/touch-and-input/gestures/predictive-back
Performance,Baseline Profile,Generate Baseline Profiles for startup,Use Macrobenchmark to generate include in app,Skip baseline profiles for release,"profileinstaller + macrobenchmark BaselineProfileRule","No baseline profile module",High,https://developer.android.com/topic/performance/baselineprofiles
Performance,R8 Full Mode,Enable R8 full mode for max optimization,Set android.enableR8.fullMode=true,Use default R8 mode only,"android.enableR8.fullMode=true in gradle.properties","Default R8 without full mode",Medium,https://developer.android.com/build/shrink-code
Performance,Strict Mode,Use StrictMode in debug to detect issues,Enable disk/network on main thread detection,Run StrictMode in release,"StrictMode.setThreadPolicy(detectAll().penaltyLog().build())","No StrictMode configured",Medium,https://developer.android.com/reference/android/os/StrictMode
Performance,Compose Stability,Check Compose compiler stability report,Generate stability report fix unstable params,Ignore stability warnings,"composeCompiler { reportsDestination = buildDir('compose_reports') }","No stability analysis",Medium,https://developer.android.com/develop/ui/compose/performance/stability
Performance,Image Loading Size,Load images at display size not original,Use Coil/Glide size transformations,Load full-res images into small views,"AsyncImage(model = ImageRequest.Builder(ctx).data(url).size(200).build())","AsyncImage(model = url) // loads full size",High,
Performance,ProGuard Rules,Write correct ProGuard/R8 rules,Keep serialization models add rules for reflection,Keep everything or nothing,"-keep class com.myapp.model.** { *; }","-keep class ** { *; } // keeps everything",Medium,https://developer.android.com/build/shrink-code
Performance,Lazy Performance,Optimize LazyColumn/LazyRow performance,Use key contentType avoid heavy items,No keys no contentType,"LazyColumn { items(list key = { it.id } contentType = { it.type }) {} }","LazyColumn { items(list) { HeavyComposable() } }",High,https://developer.android.com/develop/ui/compose/lists
Testing,Compose Test Rule,Use ComposeTestRule for UI tests,Set up test rule with createComposeRule,Test compose with Espresso only,"@get:Rule val rule = createComposeRule(); rule.setContent { MyScreen() }","ActivityScenarioRule for Compose tests",Medium,https://developer.android.com/develop/ui/compose/testing
Testing,Coroutine Test,Use runTest for testing coroutines,Use Turbine for Flow TestDispatcher for time,Test with Thread.sleep or delay,"runTest { viewModel.state.test { assertEquals(Loading awaitItem()) } }","runBlocking { delay(1000); assertEquals(expected) }",High,https://developer.android.com/kotlin/coroutines/test
Testing,Hilt Test,Use HiltTestApplication for integration tests,Annotate @HiltAndroidTest use @BindValue for fakes,Create Hilt modules manually in tests,"@HiltAndroidTest class MyTest { @BindValue val repo: Repo = FakeRepo() }","Manual DI setup in test classes",Medium,https://developer.android.com/training/dependency-injection/hilt-testing
Testing,Screenshot Test,Use Paparazzi for Compose screenshot tests,Test visual regressions without emulator,Only visual testing on device,"@Test fun snapshot() { paparazzi.snapshot { MyScreen(state) } }","Manual visual checking only",Low,https://github.com/cashapp/paparazzi
Material3,Dynamic Color,Use dynamic color theming with Material3,dynamicDarkColorScheme/dynamicLightColorScheme on Android 12+,Hardcoded colors ignoring system theme,"val colorScheme = if (Build.VERSION.SDK_INT >= 31) dynamicDarkColorScheme(context) else DarkColorScheme","val colorScheme = darkColorScheme() // ignores wallpaper",Medium,https://developer.android.com/develop/ui/compose/designsystems/material3
Material3,TopAppBar Scroll,Use TopAppBar with scroll behavior,TopAppBar with scrollBehavior for collapsing,Static TopAppBar that doesn't respond to scroll,"TopAppBar(title = { Text(title) } scrollBehavior = scrollBehavior)","TopAppBar(title = { Text(title) }) // no scroll behavior",Medium,https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#TopAppBar
Material3,Scaffold Usage,Use Scaffold for standard screen layout,Scaffold with topBar bottomBar snackbarHost floatingActionButton,Manual Column layout mimicking scaffold,"Scaffold(topBar = { TopAppBar() } bottomBar = { NavBar() } snackbarHost = { SnackbarHost(hostState) }) { paddingValues -> Content(Modifier.padding(paddingValues)) }","Column { TopBar(); Content(); BottomBar() } // no insets",High,https://developer.android.com/develop/ui/compose/components/scaffold
Material3,SnackbarHost,Use SnackbarHostState with Scaffold for snackbars,SnackbarHostState + LaunchedEffect to show snackbar,Toast.makeText for user feedback,"val snackbarHostState = remember { SnackbarHostState() }; LaunchedEffect(message) { snackbarHostState.showSnackbar(message) }","Toast.makeText(context message Toast.LENGTH_SHORT).show()",Medium,https://developer.android.com/develop/ui/compose/components/snackbar
Material3,BottomSheet,Use ModalBottomSheet from Material3,ModalBottomSheet with rememberModalBottomSheetState,Custom Dialog trying to look like bottom sheet,"ModalBottomSheet(onDismissRequest = { onDismiss() } sheetState = sheetState) { Content() }","Dialog { Surface(shape = BottomSheetShape) { Content() } } // wrong",Medium,https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#ModalBottomSheet
Material3,TextField Variants,Use OutlinedTextField or TextField from M3,OutlinedTextField with proper label supportingText isError,BasicTextField for standard input,OutlinedTextField(value = text onValueChange = { text = it } label = { Text('Email') } isError = hasError supportingText = { if (hasError) Text('Invalid email') }),"BasicTextField(value = text onValueChange = { text = it }) // no styling",Medium,https://developer.android.com/develop/ui/compose/text/user-input
Material3,NavigationBar,Use NavigationBar for bottom navigation,NavigationBar with NavigationBarItem and selected state,Custom Row with icon buttons for navigation,"NavigationBar { items.forEach { NavigationBarItem(selected = it == current onClick = { nav(it) } icon = { Icon(it.icon) } label = { Text(it.label) }) } }","Row { icons.forEach { IconButton(onClick = {}) { Icon(it) } } }",High,https://developer.android.com/develop/ui/compose/components/bottom-navigation
Material3,Adaptive Layout,Use adaptive layouts for different screen sizes,WindowSizeClass for responsive layout decisions,Fixed layout ignoring screen size,"val windowSizeClass = calculateWindowSizeClass(this); when (windowSizeClass.widthSizeClass) { Compact -> PhoneLayout(); Medium -> TabletLayout() }","Fixed single-column layout on all screens",Medium,https://developer.android.com/develop/ui/compose/layouts/adaptive
Gradle,Version Catalog,Use Gradle Version Catalog (libs.versions.toml),Centralize versions in gradle/libs.versions.toml,Hardcode versions in each build.gradle,"implementation(libs.compose.material3) // from version catalog","implementation('androidx.compose.material3:material3:1.2.0') // hardcoded",High,https://developer.android.com/build/migrate-to-catalogs
Gradle,Convention Plugins,Use convention plugins for shared build logic,buildSrc or build-logic module with convention plugins,Copy-paste build config across modules,"plugins { id('myapp.android.library') } // convention plugin","Duplicate android {} block in every module",Medium,https://developer.android.com/build/migrate-to-catalogs
Gradle,Compose BOM,Use Compose BOM to manage Compose versions,Single BOM controls all Compose library versions,Manually version each Compose dependency,"implementation(platform(libs.compose.bom)); implementation(libs.compose.material3) // no version","implementation('androidx.compose.ui:ui:1.6.0') // manual version",High,https://developer.android.com/develop/ui/compose/bom
Gradle,KSP over KAPT,Use KSP instead of KAPT for annotation processing,KSP for Hilt Room Moshi - 2x faster builds,KAPT slows build and is in maintenance mode,"ksp(libs.hilt.compiler); ksp(libs.room.compiler)","kapt(libs.hilt.compiler) // slower deprecated",High,https://developer.android.com/build/migrate-to-ksp
Gradle,Build Config,Use BuildConfig for environment-specific values,buildConfigField for API URLs and feature flags,Hardcode API URLs in source code,"buildConfigField('String' 'BASE_URL' '\"https://api.example.com\"')","const val BASE_URL = 'https://api.example.com' // hardcoded",Medium,
Gradle,Dependency Configurations,Use correct dependency configurations,implementation for internal api for exposed testImplementation for tests,Use api for everything leaking transitive deps,"implementation(libs.retrofit) // internal to module","api(libs.retrofit) // exposes to all consumers",Medium,https://developer.android.com/build/dependencies
Navigation,Type-Safe Routes,Use type-safe Navigation Compose routes,@Serializable data classes for route definitions,String-based route patterns,"@Serializable data class DetailRoute(val id: Int); composable<DetailRoute> { entry -> DetailScreen(entry.toRoute<DetailRoute>().id) }","composable('detail/{id}') { backStackEntry -> val id = backStackEntry.arguments?.getString('id') }",High,https://developer.android.com/guide/navigation/design/type-safety
Navigation,Nested NavGraphs,Use nested navigation graphs for feature grouping,Separate NavGraph per feature module,Single flat navigation graph,"navigation<FeatureRoute>(startDestination = ListRoute) { composable<ListRoute> {}; composable<DetailRoute> {} }","All composable() in single NavHost // no grouping",Medium,https://developer.android.com/guide/navigation/design/nested-graphs
Navigation,Result Passing,Pass results back via SavedStateHandle,previousBackStackEntry.savedStateHandle for results,SharedViewModel or global state for screen results,"navController.previousBackStackEntry?.savedStateHandle?.set('result' value)","sharedViewModel.result = value // wrong scope",Medium,
Compose,Modifier.semantics,Add semantics for accessibility,Proper contentDescription and semantic properties,Skip accessibility annotations,"Image(painter icon contentDescription = 'Profile photo')","Image(painter icon contentDescription = null) // inaccessible",High,https://developer.android.com/develop/ui/compose/accessibility
Compose,SubcomposeLayout,Use SubcomposeLayout for dependent measurements,SubcomposeLayout when child size depends on sibling,BoxWithConstraints for all measurement needs,"SubcomposeLayout { constraints -> val mainPlaceable = subcompose('main') { MainContent() }.first().measure(constraints) }","BoxWithConstraints everywhere // less efficient",Low,
Compose,Shared Element Transitions,Use shared element transitions in Navigation,SharedTransitionLayout with AnimatedContent,No transition between screens,"SharedTransitionLayout { AnimatedContent(targetState) { state -> when(state) { ... } } }","No transitions between screens",Low,https://developer.android.com/develop/ui/compose/animation/shared-elements
Architecture,Data Layer Organization,Define a clear data layer containing repositories and data sources in a data package or module,"Create repositories even for single data sources, organize in data/ package",Let UI components interact directly with databases or APIs directly,,"ViewModel directly accessing Room DAO or Retrofit service",High,https://developer.android.com/topic/architecture/recommendations
Architecture,UI Layer Organization,Define a clear UI layer for displaying data and handling user interaction in a ui package or module,Organize UI types in ui/ package or module,Mix UI and data layer types in same package,,,High,https://developer.android.com/topic/architecture/recommendations
Architecture,Domain Layer,Use domain layer with use cases when reusing business logic across multiple ViewModels or simplifying complex ViewModel logic,Add use cases for shared cross-ViewModel business logic,Add domain layer to every project regardless of complexity,"class GetLatestNewsUseCase(val repo: NewsRepo) { operator fun invoke(): Flow<List<News>> = repo.getNews() }","Duplicate business logic across ViewModels",Medium,https://developer.android.com/topic/architecture/recommendations
Architecture,Unidirectional Data Flow,"Follow UDF where ViewModels expose UI state via observer pattern and receive actions from UI through method calls",ViewModels expose StateFlow and receive user actions via methods,Bidirectional data binding or direct state mutation from UI,"class MyVM : ViewModel() { val uiState: StateFlow<UiState>; fun onAction(action: Action) {} }","Two-way data binding modifying ViewModel state directly",Critical,https://developer.android.com/topic/architecture/recommendations
Architecture,No ViewModel Events to UI,Process events immediately in ViewModel and cause a state update with the result rather than sending one-off events to UI,Process events in ViewModel and update state,Send SingleLiveEvent or Channel events to UI,"fun onBookmark() { _uiState.update { it.copy(isBookmarked = true) } }","val events: Channel<Event> // one-off events to UI",High,https://developer.android.com/topic/architecture/recommendations
Architecture,Use Jetpack Compose,"Use Jetpack Compose for building new apps on phones, tablets, foldables, and Wear OS",Adopt Compose for new projects and new screens,Start new projects with XML Views only,,"New project using only XML layouts and fragments",Medium,https://developer.android.com/topic/architecture/recommendations
ViewModel,Lifecycle Agnostic ViewModel,"ViewModels should not hold references to Lifecycle-related types like Activity, Fragment, Context, or Resources",Keep ViewModel free of Android framework references,"Pass Activity, Fragment, Context, or Resources to ViewModel","class MyVM @Inject constructor(val repo: Repo) : ViewModel()","class MyVM(val context: Context) : ViewModel() // holds Context",Critical,https://developer.android.com/topic/architecture/recommendations
ViewModel,Screen-Level ViewModel,Use ViewModels only at screen level not in reusable UI components,Use ViewModels in screen composables or Activity/Fragment/nav destinations,Use ViewModels in reusable composable components,"@Composable fun ProfileScreen(vm: ProfileVM = hiltViewModel()) {}","@Composable fun UserAvatar(vm: AvatarVM = viewModel()) // reusable component with VM",High,https://developer.android.com/topic/architecture/recommendations
ViewModel,Plain State Holders for Reusable UI,"Use plain state holder classes for managing complexity in reusable UI components, allowing state to be hoisted and controlled externally",Create state holder classes for complex reusable UI,Use ViewModel for reusable UI component state,"class DatePickerState(initial: LocalDate) { var selectedDate by mutableStateOf(initial) }","@HiltViewModel class DatePickerVM // ViewModel for reusable component",High,https://developer.android.com/topic/architecture/recommendations
ViewModel,Avoid AndroidViewModel,Use ViewModel class instead of AndroidViewModel. Move Application dependencies to UI or data layer.,Use ViewModel with proper DI instead of AndroidViewModel,Use AndroidViewModel to access Application context,"@HiltViewModel class MyVM @Inject constructor(repo: Repo) : ViewModel()","class MyVM(app: Application) : AndroidViewModel(app) { val ctx = app }",Medium,https://developer.android.com/topic/architecture/recommendations
ViewModel,Expose Single UiState,"Expose UI state through a single uiState property as StateFlow. Use stateIn with WhileSubscribed(5000) for stream data or MutableStateFlow for simpler cases.",Single uiState StateFlow with stateIn WhileSubscribed(5000),Multiple scattered LiveData or state properties,"val uiState: StateFlow<UiState> = repo.dataStream().map { UiState.Success(it) }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), UiState.Loading)","val loading = MutableLiveData<Boolean>(); val data = MutableLiveData<List<Item>>(); val error = MutableLiveData<String>() // scattered",High,https://developer.android.com/topic/architecture/recommendations
Lifecycle,No Lifecycle Method Override,"Do not override lifecycle methods like onResume in Activities or Fragments. Use LifecycleObserver and repeatOnLifecycle API instead.",Use LifecycleObserver and repeatOnLifecycle,"Override onResume, onPause, onStart in Activity/Fragment","lifecycle.addObserver(object : DefaultLifecycleObserver { override fun onResume(owner: LifecycleOwner) {} })","override fun onResume() { super.onResume(); loadData() }",High,https://developer.android.com/topic/architecture/recommendations
Architecture,DI Scoping,Scope dependencies to a container when the type contains mutable shared data or is expensive to initialize and widely used,Scope expensive or shared-state dependencies to appropriate container,Create new instances of expensive objects every time,"@Singleton class UserSessionManager @Inject constructor()","fun provideUserSession() = UserSessionManager() // new instance each time",High,https://developer.android.com/topic/architecture/recommendations
Testing,Know What to Test,"At minimum: unit test ViewModels including Flows, unit test data layer entities, and UI navigation tests for regression in CI","Test ViewModels, repositories, data sources, and navigation",Skip testing or only test manually,"@Test fun uiState_initially_loading() = runTest { assertEquals(Loading, viewModel.uiState.value) }","No automated tests",High,https://developer.android.com/topic/architecture/recommendations
Testing,Prefer Fakes Over Mocks,Use fake implementations instead of mocking frameworks for test doubles,Create Fake implementations of interfaces,Use Mockito/Mockk for everything,"class FakeUserRepo : UserRepo { override suspend fun getUser(id: String) = testUser }","val repo = mockk<UserRepo>(); every { repo.getUser(any()) } returns testUser",High,https://developer.android.com/topic/architecture/recommendations
Testing,Test StateFlows,"When testing StateFlow: assert on value property when possible, create collectJob when using WhileSubscribed",Assert StateFlow.value directly or use Turbine,Use Thread.sleep or delay to wait for state,"@Test fun test() = runTest { val vm = MyVM(); assertEquals(expected, vm.uiState.value) }","@Test fun test() { Thread.sleep(1000); assertEquals(expected, vm.state.value) }",High,https://developer.android.com/topic/architecture/recommendations
Architecture,Model Per Layer,"In complex apps create separate models per layer: remote DTOs, local entities, and UI models",Map between network/database/UI models at layer boundaries,Use single model class across all layers,"data class UserDto(...); data class UserEntity(...); data class UserUiModel(...)","data class User(...) // same class for API DB and UI",Medium,https://developer.android.com/topic/architecture/recommendations
Naming,Method Naming,Methods should be named as verb phrases,Use verb phrases for method names,Use noun phrases for methods,"fun makePayment()","fun payment()",Low,https://developer.android.com/topic/architecture/recommendations
Naming,Property Naming,Properties should be named as noun phrases,Use noun phrases for property names,Use verb phrases for properties,"val inProgressTopicSelection","val selectTopicsInProgress",Low,https://developer.android.com/topic/architecture/recommendations
Naming,Stream Naming,"Name stream-returning functions as get{Model}Stream(). Use plural for lists: get{Models}Stream()",Follow get{Model}Stream() pattern for Flow/LiveData functions,Inconsistent naming for stream functions,"fun getAuthorStream(): Flow<Author>; fun getAuthorsStream(): Flow<List<Author>>","fun fetchAuthor(): Flow<Author>; fun observeAuthors(): Flow<List<Author>>",Low,https://developer.android.com/topic/architecture/recommendations
Naming,Interface Implementation Naming,"Use meaningful names for interface implementations. Use Default prefix if no better name. Fake prefix for test doubles.",Name implementations descriptively like OfflineFirstNewsRepo,Generic Impl suffix for all implementations,"class OfflineFirstNewsRepository : NewsRepository; class FakeNewsRepository : NewsRepository","class NewsRepositoryImpl : NewsRepository // generic Impl",Low,https://developer.android.com/topic/architecture/recommendations
SOLID,Single Responsibility Principle,"Each class should have one reason to change. ViewModel owns UI logic, Repository owns data access, UseCase owns business rules. When a class changes for multiple unrelated reasons split it.",One class = one job. ViewModel for UI state; Repository for data; UseCase for business logic,God class handling networking + caching + UI state + validation in one place,"class AuthRepository @Inject constructor(private val api: AuthApi, private val dao: AuthDao) { suspend fun login(credentials: Credentials): Result<User> = try { val user = api.login(credentials); dao.insert(user); Result.success(user) } catch (e: Exception) { Result.failure(e) } }","class LoginViewModel : ViewModel() { private val retrofit = Retrofit.Builder().baseUrl(URL).build(); private val db = Room.databaseBuilder(ctx, AppDb::class.java, 'db').build(); fun login(email: String, pwd: String) { /* validates + calls API + caches + updates UI state */ } }",Critical,
SOLID,Open-Closed Principle,"Software entities should be open for extension but closed for modification. Add new behavior through new implementations of interfaces rather than modifying existing code with conditional branches.",Define interfaces and add new implementations; avoid growing if/else or when chains,Modify existing classes every time a new variant is needed,"interface NotificationSender { suspend fun send(notification: Notification) }; class PushNotificationSender @Inject constructor(private val fcm: FirebaseMessaging) : NotificationSender { override suspend fun send(n: Notification) { fcm.send(n.toRemoteMessage()) } }; class EmailNotificationSender @Inject constructor(private val mailer: Mailer) : NotificationSender { override suspend fun send(n: Notification) { mailer.send(n.toEmail()) } }","fun sendNotification(type: String, notification: Notification) { when (type) { 'push' -> { /* FCM logic */ }; 'email' -> { /* email logic */ }; 'sms' -> { /* sms logic */ } /* add new else branch for every type forever */ } }",High,
SOLID,Liskov Substitution Principle,"Subtypes must be substitutable for their base types. Every implementation of an interface must fully honor its contract without throwing unexpected exceptions or silently skipping behavior.",Subclasses honor the full contract of the parent interface or class,Subclasses that throw UnsupportedOperationException or silently no-op required methods,"interface UserRepository { fun getUsers(): Flow<List<User>>; suspend fun save(user: User) }; class LocalUserRepository @Inject constructor(private val dao: UserDao) : UserRepository { override fun getUsers() = dao.observeAll(); override suspend fun save(user: User) = dao.upsert(user) }","class ReadOnlyUserRepository : UserRepository { override fun getUsers() = flowOf(cachedList); override suspend fun save(user: User) { throw UnsupportedOperationException('Read-only') /* violates contract */ } }",High,
SOLID,Interface Segregation Principle,"No client should be forced to depend on methods it does not use. Split fat interfaces into smaller role-specific ones so implementations and consumers only see what they need.",Small focused interfaces per role; classes implement only what they need,One large interface forcing every implementation to stub unused methods,"interface UserReader { fun getUser(id: String): Flow<User> }; interface UserWriter { suspend fun saveUser(user: User) }; class ProfileViewModel @Inject constructor(private val reader: UserReader) : ViewModel() { val user = reader.getUser(userId) }","interface UserRepository { fun getUser(id: String): Flow<User>; suspend fun saveUser(user: User); suspend fun deleteUser(id: String); suspend fun exportUsers(): File; suspend fun syncUsers() } /* ProfileScreen only needs getUser but depends on everything */ ",High,
SOLID,Dependency Inversion Principle,"High-level modules should depend on abstractions not on concrete low-level details. ViewModel depends on a Repository interface not on Retrofit or Room directly. Bindings are configured in DI modules.",Depend on interfaces. Bind implementations in Hilt modules,ViewModel or UseCase directly creating or referencing Retrofit/Room/SharedPreferences,"interface OrderRepository { fun getOrders(): Flow<List<Order>> }; @HiltViewModel class OrderViewModel @Inject constructor(private val repo: OrderRepository) : ViewModel() { val orders = repo.getOrders().stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList()) }","class OrderViewModel : ViewModel() { private val api = RetrofitClient.instance.create(OrderApi::class.java); private val dao = AppDatabase.instance.orderDao(); fun load() { viewModelScope.launch { val orders = api.getOrders(); dao.insertAll(orders) } } }",Critical,
CleanCode,Small Focused Functions,"Each function should do exactly one thing at one level of abstraction. If you need comments to separate sections inside a function it should be multiple functions. Aim for 5-20 lines per function.",One function = one task. Extract each logical step into a well-named private function,Functions longer than 30 lines doing multiple unrelated steps,"suspend fun syncUser(id: String) { val remote = fetchRemoteUser(id); val merged = mergeWithLocal(remote); saveUser(merged) }; private suspend fun fetchRemoteUser(id: String): UserDto = api.getUser(id); private suspend fun mergeWithLocal(remote: UserDto): User { val local = dao.getUser(remote.id); return local?.merge(remote.toDomain()) ?: remote.toDomain() }; private suspend fun saveUser(user: User) = dao.upsert(user)","suspend fun syncUser(id: String) { /* 80 lines: fetch from API, check cache, parse JSON, transform model, handle 5 error cases, update DB, notify UI, log analytics */ }",High,
CleanCode,Meaningful Naming,"Names should reveal intent and use domain vocabulary. Avoid abbreviations (mgr ctx btn) single-letter variables and generic names (data info temp handler). Longer scope = longer name.",Names describe what/why not how. Use domain terms. Full words over abbreviations,"val isUserAuthenticated: Boolean; suspend fun fetchUserProfile(userId: String): User; class PaymentRepository; sealed interface CheckoutUiState","val flag: Boolean; fun proc(s: String): Any?; class Mgr; data class Data(val x: List<Any>)",High,
CleanCode,Avoid Magic Numbers and Strings,"Replace every hardcoded literal with a named constant or enum. Named constants serve as documentation and create single-source-of-truth for values used in multiple places.",Named constants in companion object or top-level. Use enums for related sets,Raw numbers and strings scattered in logic and UI code,"private companion object { const val MAX_RETRY = 3; const val TIMEOUT_MS = 5_000L; const val DEBOUNCE_MS = 300L }; retry(MAX_RETRY) { withTimeout(TIMEOUT_MS) { api.fetch() } }","if (count < 3) { delay(5000); api.fetch() } // what is 3? what is 5000?",Medium,
CleanCode,Guard Clauses and Early Return,"Validate preconditions at the top of functions and return/throw early. This eliminates nesting and keeps the happy path at the lowest indentation level.",Return or throw early for invalid cases. Happy path stays unnested at base indentation,Deeply nested if/else pyramids,"fun processPayment(order: Order?): Result<Receipt> { if (order == null) return Result.failure(IllegalArgumentException('Order required')); if (order.items.isEmpty()) return Result.failure(EmptyCartException()); if (!order.isValid()) return Result.failure(InvalidOrderException()); return paymentGateway.charge(order) }","fun processPayment(order: Order?): Result<Receipt> { if (order != null) { if (order.items.isNotEmpty()) { if (order.isValid()) { return paymentGateway.charge(order) } else { return Result.failure(InvalidOrderException()) } } else { return Result.failure(EmptyCartException()) } } else { return Result.failure(IllegalArgumentException('Order required')) } }",Medium,
CleanCode,DRY - Extract Shared Logic,"When the same logic appears in two or more places extract it into a single shared function or extension. Update all call sites to use the shared version.",Extract repeated logic into extension functions or shared helpers,Copy-pasting the same validation/formatting/mapping logic across classes,"fun String.toDisplayDate(): String = LocalDate.parse(this).format(DateTimeFormatter.ofPattern('MMM dd, yyyy')); /* used in OrderScreen, ProfileScreen, HistoryScreen */","// OrderScreen: LocalDate.parse(date).format(DateTimeFormatter.ofPattern('MMM dd, yyyy')); // ProfileScreen: LocalDate.parse(date).format(DateTimeFormatter.ofPattern('MMM dd, yyyy')); // HistoryScreen: same again",High,
CleanCode,Immutability by Default,"Use val over var and immutable collections over mutable. Data classes with val properties are inherently safe to share across threads. Mutable state should be isolated and controlled.",val for everything. Immutable data classes. MutableStateFlow only inside ViewModel,var and MutableList scattered across classes,"data class UserUiState(val name: String, val email: String, val posts: ImmutableList<Post> = persistentListOf()); class UserViewModel : ViewModel() { private val _uiState = MutableStateFlow(UserUiState()); val uiState: StateFlow<UserUiState> = _uiState.asStateFlow() }","class UserViewModel : ViewModel() { var name = ''; var email = ''; var posts = mutableListOf<Post>(); var isLoading = false }",High,
CleanCode,Kotlin Extension Functions,"Use extension functions to add behavior to existing types instead of utility classes with static methods. Keep extensions focused and discoverable by placing them near their domain.",Extension functions on types for domain operations. Place near usage or in type-specific files,Java-style static utility classes,"fun User.toUiModel() = UserUiModel(displayName = '$firstName $lastName', avatar = avatarUrl.orDefault()); fun Long.toFormattedDuration(): String { val minutes = this / 60_000; val seconds = (this % 60_000) / 1000; return '${minutes}m ${seconds}s' }","object UserUtils { fun getDisplayName(user: User) = '${user.firstName} ${user.lastName}'; fun getAvatar(user: User) = user.avatarUrl ?: DEFAULT }; object TimeUtils { fun format(ms: Long): String { /* ... */ } }",Medium,
CleanCode,Sealed Types for Exhaustive State,"Model finite state sets with sealed class/interface so the compiler enforces exhaustive when branches. Adding a new subtype triggers compile errors at every unhandled when.",Sealed interface for UI state and result types. when expression handles all cases,Boolean flags or nullable fields creating impossible/ambiguous state combinations,"sealed interface HomeUiState { data object Loading : HomeUiState; data class Success(val articles: List<Article>) : HomeUiState; data class Error(val message: String) : HomeUiState }; when (state) { is Loading -> CircularProgressIndicator(); is Success -> ArticleList(state.articles); is Error -> ErrorMessage(state.message) }","data class HomeUiState(val articles: List<Article>? = null, val isLoading: Boolean = false, val error: String? = null) // isLoading=true AND error!=null at same time?",High,
CleanCode,Avoid Deep Nesting,"Maximum 2-3 levels of indentation. Use early returns and when expressions and function extraction to flatten deeply nested code. Deep nesting signals that a function is doing too much.",Max 2-3 indent levels. Flatten with early return + when + extract function,4+ levels of nested if/for/try blocks,"fun getUserLabel(user: User?): String { val name = user?.name ?: return 'Guest'; if (name.isBlank()) return 'Anonymous'; return name.replaceFirstChar { it.uppercase() } }","fun getUserLabel(user: User?): String { if (user != null) { if (user.name != null) { if (user.name.isNotBlank()) { return user.name.replaceFirstChar { it.uppercase() } } else { return 'Anonymous' } } else { return 'Guest' } } else { return 'Guest' } }",Medium,
CleanCode,Composition Over Inheritance,"Favor interfaces and delegation over class hierarchies. Kotlin class delegation (by keyword) makes composition as concise as inheritance while being more flexible and avoiding fragile base class issues.",Interface + delegation for shared behavior. Shallow hierarchy max 1-2 levels,Deep inheritance chains or abstract base classes with half-implemented methods,"interface Analytics { fun track(event: String) }; class ScreenViewModel(private val analytics: Analytics) : ViewModel(), Analytics by analytics","open class BaseViewModel : ViewModel() { /* shared stuff */ }; open class BaseListViewModel : BaseViewModel() { /* list stuff */ }; open class BaseSearchableListViewModel : BaseListViewModel() { /* search stuff */ }; class UserListViewModel : BaseSearchableListViewModel() // 4 levels deep",High,
DI,Constructor Injection Always,"Always prefer constructor injection. It makes dependencies explicit visible in the class signature and trivially testable. Use field injection (@Inject lateinit var) only in Android framework classes where constructors are not controlled (Activity Fragment).",@Inject constructor for all classes. Field injection only in Activity/Fragment,Field injection in ViewModel Repository UseCase or any non-framework class,"class UserRepository @Inject constructor(private val api: UserApi, private val dao: UserDao, @IoDispatcher private val dispatcher: CoroutineDispatcher)","class UserRepository { @Inject lateinit var api: UserApi; @Inject lateinit var dao: UserDao /* hidden dependencies impossible to provide in tests */ }",High,https://developer.android.com/training/dependency-injection#di-manual
DI,Hilt Module Organization,"Group Hilt modules by layer: DataModule for repositories and data sources, NetworkModule for Retrofit/OkHttp, DatabaseModule for Room. Use @Binds for interface-to-impl mapping and @Provides for third-party objects.",Separate modules per layer. @Binds for interfaces; @Provides for builders and third-party types,Single AppModule providing everything in one giant file,"@Module @InstallIn(SingletonComponent::class) interface DataModule { @Binds fun bindUserRepo(impl: OfflineFirstUserRepo): UserRepository; @Binds fun bindOrderRepo(impl: DefaultOrderRepo): OrderRepository }; @Module @InstallIn(SingletonComponent::class) object NetworkModule { @Provides @Singleton fun provideOkHttp(): OkHttpClient = OkHttpClient.Builder().addInterceptor(AuthInterceptor()).build() }","@Module @InstallIn(SingletonComponent::class) object AppModule { @Provides fun provideDb(app: Application) = Room.databaseBuilder(...).build(); @Provides fun provideApi() = Retrofit.Builder()...; @Provides fun provideRepo(api: Api, db: Db) = UserRepo(api, db); /* 50+ provides in one file */ }",Medium,https://developer.android.com/training/dependency-injection/hilt-android#hilt-modules
DI,Qualifier Annotations,"Use @Qualifier to distinguish multiple bindings of the same type: different CoroutineDispatchers, different API base URLs, different OkHttpClient configs. Without qualifiers Hilt cannot tell which instance to inject.",Custom @Qualifier for same-type bindings like @IoDispatcher @DefaultDispatcher @MainDispatcher,Providing same type twice without qualifier causing Hilt compile error or wrong injection,"@Qualifier @Retention(AnnotationRetention.BINARY) annotation class IoDispatcher; @Qualifier @Retention(AnnotationRetention.BINARY) annotation class DefaultDispatcher; @Module @InstallIn(SingletonComponent::class) object DispatcherModule { @Provides @IoDispatcher fun provideIo(): CoroutineDispatcher = Dispatchers.IO; @Provides @DefaultDispatcher fun provideDefault(): CoroutineDispatcher = Dispatchers.Default }","@Provides fun provideDispatcher(): CoroutineDispatcher = Dispatchers.IO // only one binding; which dispatcher is this?",Medium,https://developer.android.com/training/dependency-injection/hilt-android#multiple-bindings
DI,Assisted Injection,"Use @AssistedInject when a class needs both DI-provided dependencies and runtime parameters (like a screen ID or user input). Avoids writing manual ViewModelProvider.Factory boilerplate.",@AssistedInject + @AssistedFactory for combining DI deps with runtime params,Manual ViewModelProvider.Factory implementations for every ViewModel that needs an argument,"class DetailViewModel @AssistedInject constructor(@Assisted private val articleId: Long, private val repo: ArticleRepository) : ViewModel() { val article = repo.getArticle(articleId).stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), null) }; @AssistedFactory interface Factory { fun create(articleId: Long): DetailViewModel }","class DetailViewModel(private val articleId: Long) : ViewModel() { class Factory(private val articleId: Long) : ViewModelProvider.Factory { override fun <T : ViewModel> create(modelClass: Class<T>): T = DetailViewModel(articleId) as T } } // manual factory boilerplate for every screen",Medium,https://developer.android.com/training/dependency-injection/hilt-android
DI,Scope to Component Lifecycle,"Match DI scope to the Android component lifecycle. @Singleton for app-wide singletons, @ActivityRetainedScoped to survive config changes, @ViewModelScoped for per-screen sharing. Over-scoping wastes memory; under-scoping causes redundant instances.",Match scope to lifecycle. @Singleton only for truly app-wide; @ViewModelScoped for screen-level sharing,@Singleton on everything or no scoping at all,"@Module @InstallIn(ViewModelComponent::class) interface ScreenModule { @Binds @ViewModelScoped fun bindGetArticlesUseCase(impl: DefaultGetArticlesUseCase): GetArticlesUseCase }; @Module @InstallIn(SingletonComponent::class) interface AppModule { @Binds @Singleton fun bindAuthManager(impl: DefaultAuthManager): AuthManager }","@Singleton class GetArticlesUseCase @Inject constructor(val repo: ArticleRepo) // lives forever even when no screen needs it; @Singleton on every class just to be safe",High,https://developer.android.com/training/dependency-injection/hilt-android#component-scopes
DI,Interface Abstraction for Testability,"Every Repository and DataSource should have an interface. Inject the interface type everywhere. In tests provide a Fake implementation via @BindValue or a test Hilt module. This makes tests fast and deterministic.",Interface for every data layer class. Inject interface types. Swap with Fakes in tests,Inject concrete classes making tests require real network/database,"interface ArticleRepository { fun getArticles(): Flow<List<Article>>; suspend fun refresh() }; class OfflineFirstArticleRepository @Inject constructor(private val api: ArticleApi, private val dao: ArticleDao) : ArticleRepository { override fun getArticles() = dao.observeAll(); override suspend fun refresh() { dao.upsertAll(api.getAll().map { it.toEntity() }) } }; // In test: class FakeArticleRepository : ArticleRepository { private val articles = MutableStateFlow<List<Article>>(emptyList()); override fun getArticles() = articles; override suspend fun refresh() { articles.value = testArticles } }","class ArticleRepository @Inject constructor(private val api: ArticleApi, private val dao: ArticleDao) { /* concrete class injected everywhere; tests need real Room + Retrofit or heavy mocking */ }",Critical,https://developer.android.com/training/dependency-injection
