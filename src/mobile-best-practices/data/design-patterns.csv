Name,Category,Platform,Keywords,Intent,Code Smell,When To Use,Structure,Bad Example,Good Example,Notes,Reference URL
Factory Method,Creational,Android,factory method creation switch when type instantiation polymorphism,Define an interface for creating objects letting subclasses decide which class to instantiate,Large when/switch block that creates different objects based on type string or enum,Creating platform-specific views | Creating different API request objects | ViewModel creation based on screen type,Creator → ConcreteCreator → Product,"when (type) {\n  ""list"" -> ListScreen()\n  ""grid"" -> GridScreen()\n  ""detail"" -> DetailScreen()\n}","interface ScreenFactory {\n  fun create(): Screen\n}\nclass ListScreenFactory : ScreenFactory {\n  override fun create() = ListScreen()\n}",In Android use Hilt @Binds with map multibinding for ViewModel factories. Compose: use CompositionLocal for factory injection.,https://refactoring.guru/design-patterns/factory-method
Factory Method,Creational,iOS,factory method creation switch pattern instantiation polymorphism swift,Define an interface for creating objects letting subclasses decide which class to instantiate,Large switch statement creating different objects based on type,Creating different view controllers | Building platform-specific UI components | Service instantiation,Protocol → ConcreteFactory → Product,"switch type {\ncase .list: return ListVC()\ncase .grid: return GridVC()\ncase .detail: return DetailVC()\n}","protocol ScreenFactory {\n  func create() -> UIViewController\n}\nclass ListScreenFactory: ScreenFactory {\n  func create() -> UIViewController { ListVC() }\n}",In SwiftUI use @EnvironmentObject or dependency container for factory injection.,https://refactoring.guru/design-patterns/factory-method
Factory Method,Creational,Flutter,factory method creation switch pattern instantiation dart widget,Define a factory constructor for creating objects based on type,Large switch creating different widgets based on type string,Creating platform-adaptive widgets | Building different page layouts | Service creation based on config,Factory constructor → Product,"switch (type) {\n  case 'list': return ListPage();\n  case 'grid': return GridPage();\n}","abstract class PageFactory {\n  Widget create();\n}\nclass ListPageFactory implements PageFactory {\n  @override\n  Widget create() => const ListPage();\n}",Dart has built-in factory constructors. Use them with abstract classes for clean factory patterns.,https://refactoring.guru/design-patterns/factory-method
Abstract Factory,Creational,All,abstract factory family platform theme component creation,Provide an interface for creating families of related objects without specifying concrete classes,Platform-specific UI components scattered across codebase with duplicated if-platform checks,Creating themed UI component sets | Platform-specific service implementations | White-label app variants,AbstractFactory → ConcreteFactory → AbstractProduct → ConcreteProduct,"if (platform == ""ios"") {\n  button = IOSButton()\n  dialog = IOSDialog()\n} else {\n  button = AndroidButton()\n  dialog = AndroidDialog()\n}","interface UIFactory {\n  fun createButton(): Button\n  fun createDialog(): Dialog\n}\nclass MaterialFactory : UIFactory { ... }\nclass CupertinoFactory : UIFactory { ... }",In Flutter use Platform.isIOS with factory. In Compose use MaterialTheme as a built-in abstract factory for theming.,https://refactoring.guru/design-patterns/abstract-factory
Builder,Creational,Android,builder telescoping constructor optional parameters configuration,Construct complex objects step by step allowing different representations,Constructor with many optional parameters | Telescoping constructors | Multiple overloaded constructors,Building complex request objects | Configuring notification builders | Multi-step form data assembly,Builder → ConcreteBuilder → Director → Product,"class Config(\n  val url: String,\n  val timeout: Int = 30,\n  val retries: Int = 3,\n  val cache: Boolean = true,\n  val headers: Map<String,String> = emptyMap()\n) // 10+ params","class Config private constructor(builder: Builder) {\n  class Builder {\n    private var url = """"\n    fun url(v: String) = apply { url = v }\n    fun build() = Config(this)\n  }\n}",Kotlin data classes with default params often eliminate the need for Builder. Use Builder only when construction has validation or ordering constraints.,https://refactoring.guru/design-patterns/builder
Builder,Creational,iOS,builder telescoping constructor optional parameters swift configuration,Construct complex objects step by step allowing different representations,Init with many optional parameters | Long initializer parameter lists,Building complex request configurations | Constructing attributed strings | Multi-step object assembly,Builder → Product,"init(url: String, timeout: Int = 30, retries: Int = 3, cache: Bool = true, headers: [String:String] = [:])","class ConfigBuilder {\n  private var url = """"\n  func url(_ v: String) -> Self { url = v; return self }\n  func build() -> Config { Config(url: url) }\n}",Swift @resultBuilder is a powerful alternative for DSL-style builders. Use for complex SwiftUI view composition.,https://refactoring.guru/design-patterns/builder
Singleton,Creational,Android,singleton global state shared instance single object,Ensure a class has only one instance and provide global access to it,Multiple instances of a manager class causing state inconsistencies | Global mutable state accessed everywhere,Database instance | Shared preferences wrapper | Analytics tracker | Network client,Singleton → Instance,"class DbHelper {\n  companion object {\n    var instance: DbHelper? = null\n    fun get(): DbHelper {\n      if (instance == null) instance = DbHelper()\n      return instance!!\n    }\n  }\n}","@Singleton\nclass DbHelper @Inject constructor(\n  private val db: AppDatabase\n) { ... }",Avoid manual singletons in Android. Use Hilt @Singleton scope instead. Manual singletons leak context and prevent testing.,https://refactoring.guru/design-patterns/singleton
Singleton,Creational,Flutter,singleton global state shared instance dart single,Ensure a class has only one instance and provide global access to it,Multiple instances causing duplicated state | Global variables scattered across files,Service locators | Shared configuration | Event bus,Singleton → Instance,"class ApiClient {\n  static ApiClient? _instance;\n  factory ApiClient() {\n    _instance ??= ApiClient._();\n    return _instance!;\n  }\n  ApiClient._();\n}","// Use get_it or riverpod instead\nfinal getIt = GetIt.instance;\ngetIt.registerSingleton<ApiClient>(ApiClient());",Prefer get_it or riverpod for DI over manual singletons. Manual singletons make testing and hot reload harder in Flutter.,https://refactoring.guru/design-patterns/singleton
Adapter,Structural,Android,adapter wrapper interface incompatible api response mapping convert,Convert the interface of a class into another interface clients expect,Manual mapping code duplicated across multiple call sites | Incompatible third-party API responses,Mapping API DTOs to domain models | Wrapping legacy code | Converting between library types,Target → Adapter → Adaptee,"// Scattered everywhere\nval user = User(\n  name = response.full_name,\n  email = response.email_address,\n  avatar = response.profile_image_url\n)","class UserMapper {\n  fun toDomain(dto: UserDto): User = User(\n    name = dto.full_name,\n    email = dto.email_address,\n    avatar = dto.profile_image_url\n  )\n}",Essential for Clean Architecture. Place mappers at layer boundaries. In Kotlin use extension functions for concise mapping.,https://refactoring.guru/design-patterns/adapter
Adapter,Structural,Flutter,adapter wrapper interface incompatible api response mapping dart convert,Convert the interface of a class into another interface clients expect,Manual fromJson/toJson scattered | Incompatible plugin API responses,Mapping API responses to models | Wrapping platform channels | Converting between packages,Target → Adapter → Adaptee,"final user = User(\n  name: json['full_name'],\n  email: json['email_address'],\n);","class UserMapper {\n  User toDomain(UserDto dto) => User(\n    name: dto.fullName,\n    email: dto.emailAddress,\n  );\n}",Use freezed with json_serializable for automatic DTO-to-model mapping. Place mappers in data layer.,https://refactoring.guru/design-patterns/adapter
Decorator,Structural,All,decorator wrapper extend behavior dynamically composition inheritance,Attach additional responsibilities to objects dynamically without modifying their code,Subclass explosion to add feature variations | Copy-paste code for cross-cutting concerns,Adding logging to repository calls | Caching layer around data source | Adding analytics to use cases,Component → Decorator → ConcreteDecorator,"class CachingUserRepo : UserRepository { ... }\nclass LoggingUserRepo : UserRepository { ... }\nclass CachingLoggingUserRepo : UserRepository { ... } // explosion","class LoggingDecorator(private val inner: UserRepository) : UserRepository {\n  override suspend fun getUser(id: String): User {\n    log(""getUser called"")\n    return inner.getUser(id)\n  }\n}",Compose decorators via DI. In Hilt use @Binds with qualifiers. In Flutter chain providers. Keeps each concern in a single class.,https://refactoring.guru/design-patterns/decorator
Facade,Structural,All,facade simplify subsystem interface complex api,Provide a simplified interface to a complex subsystem,Client code directly calls multiple subsystem classes | Long setup sequences repeated,Wrapping complex SDK initialization | Simplifying multi-step operations | Providing clean API for feature modules,Facade → Subsystem classes,"// In ViewModel\nval auth = FirebaseAuth.getInstance()\nval db = FirebaseFirestore.getInstance()\nval storage = FirebaseStorage.getInstance()\nauth.signIn(email, pass).then { db.collection(""users"").doc(it.uid).set(data) }","class AuthFacade @Inject constructor(\n  private val auth: FirebaseAuth,\n  private val db: Firestore,\n  private val storage: Storage\n) {\n  suspend fun signUp(email: String, pass: String, profile: Profile) { ... }\n}",Common in Android for Firebase/SDK wrappers. The Repository pattern is essentially a Facade over data sources.,https://refactoring.guru/design-patterns/facade
Composite,Structural,All,composite tree recursive hierarchy nested structure,Compose objects into tree structures to represent part-whole hierarchies,Recursive if/else to handle nested structures | Type-checking for leaf vs branch nodes,Building nested navigation menus | File/folder structures | Comment threads with replies | UI component trees,Component → Leaf → Composite,"fun render(item: Any) {\n  if (item is File) renderFile(item)\n  else if (item is Folder) {\n    renderFolder(item)\n    item.children.forEach { render(it) }\n  }\n}","sealed interface FileNode {\n  fun render(): Composable\n}\nclass File : FileNode { override fun render() = ... }\nclass Folder(val children: List<FileNode>) : FileNode {\n  override fun render() { children.forEach { it.render() } }\n}",Kotlin sealed interfaces are ideal for Composite. In Flutter use widget composition naturally. In SwiftUI use ViewBuilder.,https://refactoring.guru/design-patterns/composite
Proxy,Structural,All,proxy lazy loading caching access control wrapper,Provide a surrogate or placeholder for another object to control access to it,Direct access to expensive resources without caching | Missing access control on sensitive operations,Lazy-loading images | Caching API responses | Access control for premium features | Logging method calls,Subject → Proxy → RealSubject,"// Every call hits network\nsuspend fun getUser(id: String): User {\n  return api.fetchUser(id)\n}","class CachingUserProxy(private val api: UserApi) : UserRepository {\n  private val cache = mutableMapOf<String, User>()\n  override suspend fun getUser(id: String): User {\n    return cache.getOrPut(id) { api.fetchUser(id) }\n  }\n}",In Android Coil/Glide are image loading proxies. OkHttp interceptors act as proxies. Room is a proxy over SQLite.,https://refactoring.guru/design-patterns/proxy
Observer,Behavioral,Android,observer event listener callback reactive flow state notification,Define a subscription mechanism to notify multiple objects about events,Manual callback interfaces with register/unregister boilerplate | Tight coupling between event producer and consumers,StateFlow/SharedFlow for UI state | LiveData observation | Event bus replacement | Reactive data streams,Subject → Observer,"interface OnDataChanged {\n  fun onChanged(data: Data)\n}\nclass Repo {\n  private val listeners = mutableListOf<OnDataChanged>()\n  fun addListener(l: OnDataChanged) { listeners.add(l) }\n  fun notify() { listeners.forEach { it.onChanged(data) } }\n}","class Repo {\n  private val _data = MutableStateFlow<Data>(initial)\n  val data: StateFlow<Data> = _data.asStateFlow()\n}\n// In Composable\nval data by repo.data.collectAsStateWithLifecycle()",Kotlin Flow/StateFlow is the modern Observer in Android. Avoid manual listener patterns. Use SharedFlow for events and StateFlow for state.,https://developer.android.com/kotlin/flow
Observer,Behavioral,iOS,observer event listener callback reactive combine notification swift,Define a subscription mechanism to notify multiple objects about events,Manual delegate/callback chains | NotificationCenter overuse,Combine publishers for data streams | @Published property wrappers | AsyncSequence observation,Subject → Observer,"protocol DataDelegate: AnyObject {\n  func onDataChanged(_ data: Data)\n}\nclass Repo {\n  weak var delegate: DataDelegate?\n  func notify() { delegate?.onDataChanged(data) }\n}","class Repo: ObservableObject {\n  @Published var data: Data = .initial\n}\n// In SwiftUI View\n@ObservedObject var repo: Repo",SwiftUI @Published + @ObservedObject is the idiomatic Observer. Use Combine for complex reactive chains. Prefer over NotificationCenter.,https://developer.apple.com/documentation/combine
Observer,Behavioral,Flutter,observer event listener callback reactive stream bloc notification dart,Define a subscription mechanism to notify multiple objects about events,Manual callback functions passed through widget tree | Scattered setState calls,BLoC streams | StreamBuilder | ValueNotifier | ChangeNotifier,Subject → Observer,"class Repo {\n  Function(Data)? onChanged;\n  void notify(Data data) {\n    onChanged?.call(data);\n  }\n}","class Repo extends ChangeNotifier {\n  Data _data = Data.initial();\n  Data get data => _data;\n  void update(Data d) { _data = d; notifyListeners(); }\n}\n// Widget: Consumer<Repo>(builder: (_, repo, __) => Text(repo.data))",Flutter has built-in Observer via ChangeNotifier + Provider or BLoC streams. Avoid manual callback passing.,https://docs.flutter.dev/data-and-backend/state-mgmt
Strategy,Behavioral,All,strategy algorithm if else switch interchangeable behavior policy,Define a family of algorithms and make them interchangeable,Long if/else or when/switch chains selecting different algorithms | Duplicated conditional logic,Choosing sort/filter algorithms | Payment method processing | Authentication strategies | Image compression,Context → Strategy → ConcreteStrategy,"fun sort(items: List<Item>, type: String): List<Item> {\n  return when (type) {\n    ""price"" -> items.sortedBy { it.price }\n    ""name"" -> items.sortedBy { it.name }\n    ""date"" -> items.sortedBy { it.date }\n    ""rating"" -> items.sortedByDescending { it.rating }\n    else -> items\n  }\n}","fun interface SortStrategy {\n  fun sort(items: List<Item>): List<Item>\n}\nval byPrice = SortStrategy { it.sortedBy { i -> i.price } }\nval byName = SortStrategy { it.sortedBy { i -> i.name } }\n// Usage: strategy.sort(items)",Kotlin fun interfaces and lambdas make Strategy lightweight. In Flutter use typedef. In Swift use closures or protocols.,https://refactoring.guru/design-patterns/strategy
Command,Behavioral,All,command undo redo action queue execute encapsulate request,Encapsulate a request as an object letting you parameterize queue and undo operations,Undo/redo logic scattered across UI | Action handling mixed into view layer | No operation history,Text editor undo/redo | Drawing app operations | Form step navigation | Offline action queue,Command → ConcreteCommand → Invoker → Receiver,"// In ViewModel mixed with UI logic\nfun onBold() { text = text.bold(); history.add(""bold"") }\nfun onUndo() {\n  when (history.last()) {\n    ""bold"" -> text = text.unbold()\n    ""italic"" -> text = text.unitalic()\n  }\n}","interface Command {\n  fun execute()\n  fun undo()\n}\nclass BoldCommand(private val editor: Editor) : Command {\n  override fun execute() { editor.bold() }\n  override fun undo() { editor.unbold() }\n}\nclass History {\n  private val stack = ArrayDeque<Command>()\n  fun execute(cmd: Command) { cmd.execute(); stack.addLast(cmd) }\n  fun undo() { stack.removeLastOrNull()?.undo() }\n}",Essential for apps with undo/redo. Combine with MVI for event sourcing. Useful for offline-first apps queuing mutations.,https://refactoring.guru/design-patterns/command
State,Behavioral,All,state machine transition if else status enum behavior change,Allow an object to alter its behavior when its internal state changes,Complex if/else chains checking current state | Scattered state transition logic | Boolean flags controlling behavior,Order status workflows | Player states (play/pause/stop) | Authentication flow | Download manager states,Context → State → ConcreteState,"fun handle(order: Order) {\n  if (order.status == ""pending"") {\n    if (canProcess(order)) { order.status = ""processing"" }\n  } else if (order.status == ""processing"") {\n    if (isShipped(order)) { order.status = ""shipped"" }\n  } else if (order.status == ""shipped"") { ... }\n}","sealed class OrderState {\n  abstract fun next(order: Order): OrderState\n  object Pending : OrderState() {\n    override fun next(order: Order) = if (canProcess(order)) Processing else this\n  }\n  object Processing : OrderState() {\n    override fun next(order: Order) = if (isShipped(order)) Shipped else this\n  }\n}",Kotlin sealed classes are perfect for State pattern. Combine with MVI for predictable state machines. In Flutter use bloc states.,https://refactoring.guru/design-patterns/state
Template Method,Behavioral,All,template method algorithm skeleton hook override base class,Define the skeleton of an algorithm deferring some steps to subclasses,Duplicated algorithm with minor variations across classes | Copy-paste code with small differences,Base analytics tracker with platform variants | Common data sync flow | Standardized screen lifecycle,AbstractClass → ConcreteClass,"class AndroidSync {\n  fun sync() { fetchLocal(); fetchRemote(); merge(); saveLocal(); }\n}\nclass IOSSync {\n  fun sync() { fetchLocal(); fetchRemote(); merge(); saveLocal(); }\n} // duplicated","abstract class DataSync {\n  fun sync() { fetchLocal(); fetchRemote(); merge(); saveLocal() }\n  abstract fun fetchLocal(): Data\n  abstract fun fetchRemote(): Data\n  protected open fun merge(): Data { /* default merge */ }\n  abstract fun saveLocal(data: Data)\n}",In Kotlin prefer composition over inheritance when possible. Use Template Method when the algorithm skeleton is truly fixed.,https://refactoring.guru/design-patterns/template-method
Chain of Responsibility,Behavioral,All,chain responsibility handler request pipeline interceptor middleware,Pass requests along a chain of handlers letting each decide to process or pass along,Nested if/else for request validation/processing | Long validation sequences,Input validation chains | HTTP interceptor pipelines | Event handling | Permission checking,Handler → ConcreteHandler,"fun validate(input: Input): Result {\n  if (input.name.isBlank()) return Error(""Name required"")\n  if (input.email.isInvalid()) return Error(""Invalid email"")\n  if (input.age < 18) return Error(""Must be 18+"")\n  if (input.password.isWeak()) return Error(""Weak password"")\n  return Success\n}","interface Validator {\n  var next: Validator?\n  fun validate(input: Input): Result\n}\nclass NameValidator : Validator {\n  override fun validate(input: Input): Result {\n    if (input.name.isBlank()) return Error(""Name required"")\n    return next?.validate(input) ?: Success\n  }\n}",OkHttp Interceptors are a Chain of Responsibility. Use for composable validation and middleware patterns.,https://refactoring.guru/design-patterns/chain-of-responsibility
Mediator,Behavioral,All,mediator coordinator communication many-to-many decouple components,Define an object that encapsulates how a set of objects interact reducing many-to-many dependencies,Multiple components directly referencing and calling each other | Spaghetti communication between UI elements,Fragment/ViewController communication | Chat room | Form field dependencies | Multi-pane coordination,Mediator → ConcreteMediator → Colleague,"// Fragments directly calling each other\nclass ListFragment {\n  fun onItemClick(id: String) {\n    (activity as MainActivity).detailFragment.show(id)\n    (activity as MainActivity).filterFragment.highlight(id)\n  }\n}","class NavigationMediator {\n  private val colleagues = mutableMapOf<String, Fragment>()\n  fun notify(sender: String, event: Event) {\n    when (event) {\n      is ItemSelected -> colleagues[""detail""]?.show(event.id)\n    }\n  }\n}",Android Navigation Component and Jetpack Compose NavHost act as mediators. In iOS use Coordinator pattern. In Flutter use GoRouter.,https://refactoring.guru/design-patterns/mediator
Visitor,Behavioral,All,visitor double dispatch type checking sealed class operation,Define new operations on an object structure without changing the classes,Type-checking cascades with is/instanceof/as | Adding operations requires modifying every class in hierarchy,Processing AST nodes | Applying operations to sealed class hierarchies | Analytics event processing,Visitor → ConcreteVisitor → Element,"fun process(node: Node) {\n  when (node) {\n    is TextNode -> { renderText(node); logText(node); analyticsText(node) }\n    is ImageNode -> { renderImage(node); logImage(node); analyticsImage(node) }\n    is VideoNode -> { renderVideo(node); logVideo(node); analyticsVideo(node) }\n  } // every new operation adds another branch\n}","interface NodeVisitor {\n  fun visit(node: TextNode)\n  fun visit(node: ImageNode)\n  fun visit(node: VideoNode)\n}\nclass RenderVisitor : NodeVisitor { ... }\nclass AnalyticsVisitor : NodeVisitor { ... }",Kotlin sealed classes with when is often simpler than full Visitor for small hierarchies. Use Visitor when operations change more often than types.,https://refactoring.guru/design-patterns/visitor
Repository,Domain,Android,repository data source abstraction layer clean architecture,Abstract data access behind a clean interface hiding data source details,ViewModel or UI directly calling API/database | Data source logic mixed into presentation layer,Any app with remote + local data | Offline-first apps | Apps needing data caching strategy,Repository → DataSource (Remote + Local),"class UserViewModel {\n  suspend fun getUser(id: String): User {\n    val response = retrofit.create(UserApi::class.java).getUser(id)\n    val user = response.body()!!.toUser()\n    roomDb.userDao().insert(user)\n    return user\n  }\n}","interface UserRepository {\n  suspend fun getUser(id: String): User\n}\nclass UserRepositoryImpl @Inject constructor(\n  private val remote: UserRemoteDataSource,\n  private val local: UserLocalDataSource\n) : UserRepository {\n  override suspend fun getUser(id: String): User {\n    return local.getUser(id) ?: remote.getUser(id).also { local.save(it) }\n  }\n}",Core of Clean Architecture. Repository should return domain models not DTOs. Use Flow for reactive data. Inject via Hilt.,https://developer.android.com/topic/architecture/data-layer
Repository,Domain,iOS,repository data source abstraction layer clean architecture swift,Abstract data access behind a clean interface hiding data source details,View or ViewModel directly calling URLSession/CoreData | Network logic in SwiftUI views,Any app with network + persistence | Offline-first | Data synchronization,Repository → DataSource (Remote + Local),"class UserViewModel: ObservableObject {\n  func getUser(id: String) async {\n    let data = try await URLSession.shared.data(from: url)\n    let user = try JSONDecoder().decode(User.self, from: data.0)\n    try context.save()\n  }\n}","protocol UserRepository {\n  func getUser(id: String) async throws -> User\n}\nclass UserRepositoryImpl: UserRepository {\n  private let remote: UserRemoteDataSource\n  private let local: UserLocalDataSource\n  func getUser(id: String) async throws -> User {\n    if let cached = try? await local.getUser(id: id) { return cached }\n    let user = try await remote.getUser(id: id)\n    try await local.save(user)\n    return user\n  }\n}",Use Swift protocols for repository abstraction. Combine with async/await for clean data flow.,https://developer.apple.com/documentation/swiftdata
Dependency Injection,Creational,Android,dependency injection di hilt dagger constructor inject scope provide,Provide dependencies to objects rather than having them create their own,Manual object creation with constructor calls scattered | Hard-coded dependencies preventing testing,Any app beyond trivial size | Providing repositories to ViewModels | Swapping implementations for testing,Container → Module → Component → Injected class,"class UserViewModel {\n  private val repo = UserRepositoryImpl(\n    api = RetrofitClient.create(UserApi::class.java),\n    db = Room.databaseBuilder(...).build().userDao()\n  )\n}","@HiltViewModel\nclass UserViewModel @Inject constructor(\n  private val repo: UserRepository\n) : ViewModel() { ... }\n\n@Module @InstallIn(SingletonComponent::class)\nabstract class RepoModule {\n  @Binds abstract fun bindUserRepo(impl: UserRepositoryImpl): UserRepository\n}",Use Hilt for Android DI. Prefer constructor injection. Use @Binds over @Provides when possible. Scope carefully.,https://developer.android.com/training/dependency-injection/hilt-android
Dependency Injection,Creational,Flutter,dependency injection di get_it provider riverpod inject scope provide dart,Provide dependencies to objects rather than having them create their own,Manual object creation inside widgets | Hard-coded service instances,Any app with services/repositories | Testing with mock implementations | Feature modules,Container → Provider → Injected class,"class HomePage extends StatelessWidget {\n  final repo = UserRepositoryImpl(\n    api: ApiClient(),\n    db: LocalDb(),\n  );\n}","// With riverpod\nfinal userRepoProvider = Provider<UserRepository>((ref) {\n  return UserRepositoryImpl(\n    api: ref.read(apiProvider),\n    db: ref.read(dbProvider),\n  );\n});\n// In widget: ref.read(userRepoProvider)",Use riverpod or get_it for Flutter DI. Provider is simpler but less powerful. Riverpod is compile-safe and testable.,https://riverpod.dev/
Mapper,Structural,All,mapper data transfer object dto domain model convert transform,Separate data transformation logic from business logic into dedicated mapper classes,Data transformation code mixed into ViewModels or repositories | Duplicated mapping logic,Mapping API DTOs to domain models | Converting domain models to UI state | Database entity mapping,Mapper → Input → Output,"// In ViewModel\nfun loadUser(id: String) {\n  val response = api.getUser(id)\n  val user = User(\n    id = response.id,\n    fullName = ""${response.firstName} ${response.lastName}"",\n    avatarUrl = response.images.firstOrNull()?.url ?: """"\n  )\n}","class UserMapper {\n  fun toDomain(dto: UserDto): User = User(\n    id = dto.id,\n    fullName = ""${dto.firstName} ${dto.lastName}"",\n    avatarUrl = dto.images.firstOrNull()?.url ?: """"\n  )\n}\n// In Repository: mapper.toDomain(api.getUser(id))",Place mappers at layer boundaries in Clean Architecture. One mapper per DTO-to-domain conversion. Keep them pure functions.,https://developer.android.com/topic/architecture
Prototype,Creational,All,prototype clone copy duplicate object creation expensive,Create new objects by copying existing ones avoiding expensive creation,Repeated expensive object setup | Creating similar objects with minor variations,Duplicating configured objects | Copying UI component configurations | Cloning game entities,Prototype → clone(),"// Re-creating full config each time\nval config1 = NetworkConfig(timeout = 30, retries = 3, cache = true, interceptors = listOf(...))\nval config2 = NetworkConfig(timeout = 60, retries = 3, cache = true, interceptors = listOf(...)) // same but timeout","data class NetworkConfig(\n  val timeout: Int = 30,\n  val retries: Int = 3,\n  val cache: Boolean = true\n) // Kotlin data class has copy()\nval config2 = config1.copy(timeout = 60)",Kotlin data class copy() is a built-in Prototype. In Dart use copyWith(). In Swift use value types (struct) for implicit copying.,https://refactoring.guru/design-patterns/prototype
Bridge,Structural,Android,bridge abstraction implementation decouple platform variant hierarchy explosion,Decouple an abstraction from its implementation so the two can vary independently,Combinatorial explosion of subclasses when mixing two independent dimensions | Class hierarchy grows multiplicatively,"Theme × Component variations | Online/Offline × DataSource combinations | Platform × Feature implementations",Abstraction → RefinedAbstraction → Implementor → ConcreteImplementor,"class DarkListScreen : Screen { ... }\nclass LightListScreen : Screen { ... }\nclass DarkGridScreen : Screen { ... }\nclass LightGridScreen : Screen { ... }\n// 2 themes × 2 layouts = 4 classes (grows fast)","interface Theme { fun primaryColor(): Color; fun bgColor(): Color }\ninterface Screen { fun render(theme: Theme) }\nclass ListScreen : Screen {\n  override fun render(theme: Theme) { /* uses theme */ }\n}\nclass DarkTheme : Theme { ... }",Compose theming is a built-in Bridge — MaterialTheme separates theme from components. Use Bridge when you see NxM class hierarchies.,https://refactoring.guru/design-patterns/bridge
Bridge,Structural,iOS,bridge abstraction implementation decouple platform variant swift hierarchy,Decouple an abstraction from its implementation so the two can vary independently,Combinatorial subclass explosion across two independent variation axes | Duplicated code for each combination,Theme × Component styling | Renderer × Shape combinations | Storage × Serialization format,Abstraction → Implementor,"class DarkListVC: UIViewController { ... }\nclass LightListVC: UIViewController { ... }\nclass DarkGridVC: UIViewController { ... }\nclass LightGridVC: UIViewController { ... }","protocol Theme { var primary: UIColor { get }; var background: UIColor { get } }\nprotocol Screen { func render(theme: Theme) }\nclass ListScreen: Screen {\n  func render(theme: Theme) { /* uses theme */ }\n}",SwiftUI's environment-based theming is a built-in Bridge. Use this when independent dimensions cause subclass explosion.,https://refactoring.guru/design-patterns/bridge
Bridge,Structural,Flutter,bridge abstraction implementation decouple platform dart variant hierarchy,Decouple an abstraction from its implementation so the two can vary independently,Combinatorial widget explosion when mixing independent concerns | Duplicate widgets for each combination,Theme × Widget | Platform × Feature | Online/Offline × DataSource,Abstraction → Implementor,"class DarkListPage extends StatelessWidget { ... }\nclass LightListPage extends StatelessWidget { ... }\nclass DarkGridPage extends StatelessWidget { ... }\nclass LightGridPage extends StatelessWidget { ... }","abstract class AppTheme { Color get primary; Color get background; }\nabstract class PageContent { Widget build(AppTheme theme); }\nclass ListContent implements PageContent {\n  @override\n  Widget build(AppTheme theme) => ListView(/* uses theme */);\n}",Flutter's ThemeData and InheritedWidget are built-in bridges. Use explicitly when you see NxM widget proliferation.,https://refactoring.guru/design-patterns/bridge
Flyweight,Structural,Android,flyweight memory sharing cache pool object reuse intrinsic extrinsic,Share common state among many objects to reduce memory consumption,Thousands of similar objects each storing duplicate data | High memory usage from repeated object fields,Map markers with shared icons | RecyclerView item decorations | Particle effects | Chat message styling,FlyweightFactory → Flyweight → ConcreteFlyweight,"// Each marker stores its own icon bitmap\nmarkers.forEach { data ->\n  val marker = MarkerOptions()\n    .position(data.latLng)\n    .icon(BitmapDescriptorFactory.fromResource(data.iconRes)) // re-decoded each time\n  map.addMarker(marker)\n}","object MarkerIconCache {\n  private val cache = mutableMapOf<Int, BitmapDescriptor>()\n  fun get(iconRes: Int): BitmapDescriptor {\n    return cache.getOrPut(iconRes) {\n      BitmapDescriptorFactory.fromResource(iconRes)\n    }\n  }\n}\n// Usage: .icon(MarkerIconCache.get(data.iconRes))",Android BitmapPool in Glide is a Flyweight. RecyclerView.RecycledViewPool shares ViewHolders. Use when profiler shows high object allocation.,https://refactoring.guru/design-patterns/flyweight
Flyweight,Structural,Flutter,flyweight memory sharing cache pool object reuse dart intrinsic,Share common state among many objects to reduce memory consumption,Many similar widgets or objects duplicating shared data | High memory from repeated TextStyle/Decoration objects,Shared TextStyles across widgets | Icon caching | Repeated decorations in lists,FlyweightFactory → Flyweight,"// Each list item creates its own style\nListView.builder(\n  itemBuilder: (_, i) => Text(\n    items[i].name,\n    style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.black),\n  ),\n)","class AppStyles {\n  static const bodyBold = TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.black);\n}\n// Usage: Text(items[i].name, style: AppStyles.bodyBold)",Flutter const constructors are a built-in Flyweight. Always use const for TextStyle/BoxDecoration. Define theme extensions for shared styles.,https://refactoring.guru/design-patterns/flyweight
Null Object,Behavioral,Android,null object empty default avoid null check safe pattern kotlin,Provide a default no-op object instead of null to eliminate null checks,Pervasive null checks with ?. and ?: scattered throughout codebase | Nullable types where a default behavior is valid,Default analytics (no-op in debug) | Guest user object | Empty list states | Fallback logger,Interface → RealObject → NullObject,"fun trackEvent(analytics: Analytics?, event: String) {\n  analytics?.let {\n    it.logEvent(event)\n    it.setTimestamp(System.currentTimeMillis())\n    it.flush()\n  }\n}","interface Analytics {\n  fun logEvent(event: String)\n  fun flush()\n}\nclass FirebaseAnalytics : Analytics { /* real impl */ }\nobject NoOpAnalytics : Analytics {\n  override fun logEvent(event: String) {}\n  override fun flush() {}\n}\n// Usage: always non-null. analytics.logEvent(""click"")",Kotlin object is ideal for Null Objects (singleton + no-op). Eliminates entire categories of null checks. Combine with DI to swap real/no-op.,https://refactoring.guru/design-patterns/null-object
Null Object,Behavioral,iOS,null object empty default avoid optional check safe swift,Provide a default no-op object instead of optionals to eliminate nil checks,Excessive optional chaining (?) and guard-let/if-let | Optionals where default behavior exists,Default analytics in debug | Guest user fallback | Empty state handler | No-op logger,Protocol → RealObject → NullObject,"func track(analytics: Analytics?, event: String) {\n  guard let analytics = analytics else { return }\n  analytics.logEvent(event)\n  analytics.flush()\n}","protocol Analytics {\n  func logEvent(_ event: String)\n  func flush()\n}\nstruct NoOpAnalytics: Analytics {\n  func logEvent(_ event: String) {}\n  func flush() {}\n}\n// Usage: always non-nil. analytics.logEvent(""click"")",Swift structs are perfect for Null Objects. Use protocol-based Null Objects to eliminate optional ceremony throughout the codebase.,https://refactoring.guru/design-patterns/null-object
Null Object,Behavioral,Flutter,null object empty default avoid null check safe dart,Provide a default no-op object instead of null to eliminate null checks,Excessive null-aware operators (?. ?? !) throughout codebase | Nullable parameters with default behavior,Default analytics | Guest user | Empty state callbacks | No-op listeners,Interface → RealObject → NullObject,"void track(Analytics? analytics, String event) {\n  analytics?.logEvent(event);\n  analytics?.flush();\n}","abstract class Analytics {\n  void logEvent(String event);\n  void flush();\n}\nclass NoOpAnalytics implements Analytics {\n  @override\n  void logEvent(String event) {}\n  @override\n  void flush() {}\n}\n// Always non-null: analytics.logEvent('click');",Dart null-safety helps but Null Object eliminates optional ceremony entirely. Provide no-op defaults in DI for debug/test builds.,https://refactoring.guru/design-patterns/null-object
Value Object,Domain,Android,value object primitive obsession type safety domain model wrapper,Replace primitive types with meaningful domain types that enforce invariants,Primitive types (String Int) used for domain concepts like email phone money | Validation scattered at every call site,"Email validation | Money/currency handling | Phone numbers | User IDs | Coordinates",Value class → validation,"fun sendEmail(to: String) {\n  if (!to.contains(""@"")) throw IllegalArgumentException()\n  // ... use raw string everywhere\n}\nfun saveUser(name: String, email: String, phone: String, age: Int) // all primitives","@JvmInline\nvalue class Email(val value: String) {\n  init { require(value.contains(""@"")) { ""Invalid email"" } }\n}\n@JvmInline\nvalue class UserId(val value: String)\nfun sendEmail(to: Email) { /* type-safe, pre-validated */ }\nfun saveUser(name: Name, email: Email, phone: Phone, age: Age)",Kotlin value classes have zero runtime overhead. Use them for type-safe wrappers. Prevents parameter-order bugs like swapping email/phone.,https://kotlinlang.org/docs/inline-classes.html
Value Object,Domain,iOS,value object primitive obsession type safety domain model wrapper swift,Replace primitive types with meaningful domain types that enforce invariants,Raw String/Int used for domain concepts | Validation logic duplicated at multiple call sites,Email validation | Money/currency | Strong IDs | Coordinates | Measurements,Struct with validation,"func sendEmail(to: String) {\n  guard to.contains(""@"") else { return }\n  // raw string everywhere\n}\nfunc save(name: String, email: String, phone: String) // all String","struct Email {\n  let value: String\n  init?(_ value: String) {\n    guard value.contains(""@"") else { return nil }\n    self.value = value\n  }\n}\nfunc sendEmail(to: Email) { /* type-safe, pre-validated */ }",Swift structs are natural value objects. Use failable initializers for validation. Foundation has Measurement<T> as a built-in value object example.,https://developer.apple.com/documentation/foundation/measurement
Value Object,Domain,Flutter,value object primitive obsession type safety domain model wrapper dart,Replace primitive types with meaningful domain types that enforce invariants,Raw String/int used for domain concepts | Validation duplicated across widgets and blocs,Email/phone validation | Typed IDs | Money | Form field types,Class with factory validation,"void sendEmail(String to) {\n  if (!to.contains('@')) throw ArgumentError('Invalid');\n  // raw string everywhere\n}","class Email {\n  final String value;\n  Email._(this.value);\n  factory Email(String input) {\n    if (!input.contains('@')) throw ArgumentError('Invalid email');\n    return Email._(input);\n  }\n}\nvoid sendEmail(Email to) { /* type-safe */ }",Use freezed for value objects with equality/copyWith. Private constructor + factory ensures all instances are validated.,https://pub.dev/packages/freezed
Memento,Behavioral,Android,memento undo redo snapshot state save restore history,Capture and externalize an object's state so it can be restored later without violating encapsulation,Manual state backup/restore with scattered copy logic | No undo capability in editors or forms,Text/drawing editors | Form draft saving | Game save states | Navigation state preservation,Originator → Memento → Caretaker,"class Editor {\n  var text = """"\n  var cursorPos = 0\n  var formatting = mutableListOf<Format>()\n  // Manual save scattered everywhere\n  fun save(): Triple<String, Int, List<Format>> = Triple(text, cursorPos, formatting.toList())\n  fun restore(state: Triple<String, Int, List<Format>>) { /* assign each */ }\n}","data class EditorMemento(val text: String, val cursorPos: Int, val formatting: List<Format>)\nclass Editor {\n  var text = """"; var cursorPos = 0; var formatting = mutableListOf<Format>()\n  fun save(): EditorMemento = EditorMemento(text, cursorPos, formatting.toList())\n  fun restore(m: EditorMemento) { text = m.text; cursorPos = m.cursorPos; formatting = m.formatting.toMutableList() }\n}\nclass History { private val stack = ArrayDeque<EditorMemento>() }",Kotlin data classes are natural Mementos (immutable snapshots with copy). Combine with Command pattern for full undo/redo systems.,https://refactoring.guru/design-patterns/memento
Memento,Behavioral,iOS,memento undo redo snapshot state save restore history swift,Capture and externalize an object's state so it can be restored later,Manual state properties copied individually | No structured undo/redo,Text editors | Drawing apps | Form drafts | Game save/load,Originator → Memento → Caretaker,"class Editor {\n  var text = """"\n  var cursorPos = 0\n  func save() -> (String, Int) { (text, cursorPos) }\n  func restore(_ state: (String, Int)) { text = state.0; cursorPos = state.1 }\n}","struct EditorMemento: Codable {\n  let text: String\n  let cursorPos: Int\n}\nclass Editor {\n  var text = """"; var cursorPos = 0\n  func save() -> EditorMemento { EditorMemento(text: text, cursorPos: cursorPos) }\n  func restore(_ m: EditorMemento) { text = m.text; cursorPos = m.cursorPos }\n}\nclass History { private var stack: [EditorMemento] = [] }",Swift Codable structs make great Mementos. UndoManager is Foundation's built-in Memento + Command system.,https://refactoring.guru/design-patterns/memento
Specification,Domain,All,specification business rule predicate filter query compose,Encapsulate business rules into composable reusable specification objects,Complex nested if/else chains for filtering or validation | Business rules duplicated across repository queries and UI,"Product filtering with multiple criteria | User eligibility checks | Loan approval rules | Search filters",Specification → CompositeSpecification → AndSpec → OrSpec → NotSpec,"fun getEligibleUsers(users: List<User>): List<User> {\n  return users.filter {\n    it.age >= 18 &&\n    it.isVerified &&\n    it.balance >= 100 &&\n    !it.isBanned &&\n    it.country in allowedCountries &&\n    it.lastLogin.isAfter(cutoff)\n  } // duplicated in 5 places with slight variations\n}","fun interface Spec<T> {\n  fun isSatisfiedBy(item: T): Boolean\n}\nval isAdult = Spec<User> { it.age >= 18 }\nval isVerified = Spec<User> { it.isVerified }\nval isActive = Spec<User> { it.lastLogin.isAfter(cutoff) }\ninfix fun <T> Spec<T>.and(other: Spec<T>) = Spec<T> { isSatisfiedBy(it) && other.isSatisfiedBy(it) }\nval eligible = isAdult and isVerified and isActive\n// Usage: users.filter { eligible.isSatisfiedBy(it) }",Compose specifications with and/or/not operators. Each rule is testable independently. Maps naturally to SQL WHERE clauses for repository queries.,https://en.wikipedia.org/wiki/Specification_pattern
Object Pool,Creational,Android,object pool recycle reuse expensive allocation memory bitmap connection,Reuse expensive objects instead of creating and destroying them repeatedly,Frequent allocation/deallocation of expensive objects causing GC pressure | Bitmap or connection creation in loops,Bitmap pools | Database connection pools | Thread pools | RecyclerView ViewHolder pools,Pool → ReusableObject,"// Creating new bitmap for every image\nfun processImages(urls: List<String>) {\n  urls.forEach { url ->\n    val bitmap = Bitmap.createBitmap(1024, 1024, Bitmap.Config.ARGB_8888)\n    drawTo(bitmap, url)\n    display(bitmap)\n    bitmap.recycle()\n  }\n}","class BitmapPool(private val maxSize: Int = 10) {\n  private val pool = ArrayDeque<Bitmap>()\n  fun acquire(w: Int, h: Int): Bitmap {\n    return pool.removeFirstOrNull() ?: Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)\n  }\n  fun release(bitmap: Bitmap) {\n    if (pool.size < maxSize) pool.addLast(bitmap)\n    else bitmap.recycle()\n  }\n}",Glide/Coil have built-in BitmapPools. OkHttp uses connection pooling. RecyclerView.RecycledViewPool is a ViewHolder pool. Prefer library pools over custom.,https://developer.android.com/topic/performance/memory
Object Pool,Creational,Flutter,object pool recycle reuse expensive allocation memory dart,Reuse expensive objects instead of creating and destroying them repeatedly,Frequent creation of expensive objects in build methods | Repeated controller instantiation,Animation controllers | Image caches | Platform channel reuse | Heavy computation results,Pool → ReusableObject,"// New controller every rebuild\nclass AnimatedItem extends StatefulWidget {\n  @override\n  State createState() => _State();\n}\nclass _State extends State<AnimatedItem> {\n  late final controller = AnimationController(vsync: this, duration: Duration(ms: 300));\n}","class ControllerPool {\n  final _pool = <AnimationController>[];\n  AnimationController acquire(TickerProvider vsync) {\n    if (_pool.isNotEmpty) return _pool.removeLast();\n    return AnimationController(vsync: vsync, duration: const Duration(milliseconds: 300));\n  }\n  void release(AnimationController c) { c.reset(); _pool.add(c); }\n}",Flutter's ImageCache is a built-in pool. For AnimationControllers prefer SingleTickerProviderStateMixin and dispose properly rather than pooling.,https://api.flutter.dev/flutter/painting/ImageCache-class.html
Coordinator,Behavioral,iOS,coordinator navigation routing flow decouple viewcontroller presentation swift,Separate navigation logic from view controllers into dedicated coordinator objects,ViewControllers directly presenting/pushing other ViewControllers | Navigation logic mixed with UI code,Multi-step flows (onboarding/checkout) | Deep link handling | Tab-based navigation | A/B test flow variations,Coordinator → ChildCoordinator → ViewController,"class ProfileVC: UIViewController {\n  func editTapped() {\n    let vc = EditProfileVC()\n    vc.user = self.user\n    navigationController?.pushViewController(vc, animated: true)\n  }\n  func settingsTapped() {\n    let vc = SettingsVC()\n    present(vc, animated: true)\n  }\n}","protocol Coordinator {\n  var childCoordinators: [Coordinator] { get set }\n  func start()\n}\nclass ProfileCoordinator: Coordinator {\n  private let nav: UINavigationController\n  func start() { nav.pushViewController(ProfileVC(delegate: self), animated: true) }\n  func editProfile(user: User) { nav.pushViewController(EditProfileVC(user: user), animated: true) }\n  func openSettings() { SettingsCoordinator(nav: nav).start() }\n}",Essential for large iOS apps. Each flow gets its own Coordinator. Enables reuse of VCs across different flows. Pair with DI for clean architecture.,https://khanlou.com/2015/01/the-coordinator/
Coordinator,Behavioral,Android,coordinator navigation routing flow decouple screen presentation,Separate navigation logic from screens into dedicated navigator/coordinator objects,Composable screens directly calling NavController | Navigation routes hardcoded across features,Multi-step flows (onboarding/checkout) | Feature module navigation | Deep link handling,Coordinator → Navigator → Screen,"@Composable\nfun ProfileScreen(navController: NavController) {\n  Button(onClick = { navController.navigate(""edit/${user.id}"") }) { Text(""Edit"") }\n  Button(onClick = { navController.navigate(""settings"") }) { Text(""Settings"") }\n}","interface ProfileNavigator {\n  fun navigateToEdit(userId: String)\n  fun navigateToSettings()\n}\nclass ProfileNavigatorImpl(private val navController: NavController) : ProfileNavigator {\n  override fun navigateToEdit(userId: String) { navController.navigate(""edit/$userId"") }\n  override fun navigateToSettings() { navController.navigate(""settings"") }\n}\n@Composable\nfun ProfileScreen(navigator: ProfileNavigator) {\n  Button(onClick = { navigator.navigateToEdit(user.id) }) { Text(""Edit"") }\n}",Decouple screens from NavController for testability. Screens receive a navigator interface. Enables preview and testing without NavController.,https://developer.android.com/guide/navigation
Event Aggregator,Behavioral,Android,event bus aggregator decouple communication publish subscribe,Centralize event communication between decoupled components through a shared event channel,Components directly referencing each other for communication | Tight coupling between unrelated features,Analytics event dispatching | Feature flag updates | Cross-feature notifications | Session state changes,EventAggregator → Publisher → Subscriber,"// Activity directly calling fragment methods\nclass MainActivity : AppCompatActivity() {\n  fun onCartUpdated(count: Int) {\n    (supportFragmentManager.findFragmentByTag(""badge"") as? BadgeFragment)?.updateCount(count)\n    (supportFragmentManager.findFragmentByTag(""toolbar"") as? ToolbarFragment)?.refreshTitle()\n  }\n}","// Shared event flow\nobject AppEvents {\n  private val _events = MutableSharedFlow<AppEvent>()\n  val events = _events.asSharedFlow()\n  suspend fun emit(event: AppEvent) { _events.emit(event) }\n}\nsealed class AppEvent {\n  data class CartUpdated(val count: Int) : AppEvent()\n}\n// Subscribe: AppEvents.events.filterIsInstance<CartUpdated>().collect { ... }",Prefer SharedFlow over legacy EventBus libraries. Use sealed classes for type-safe events. Scope collection to lifecycle with repeatOnLifecycle.,https://developer.android.com/kotlin/flow/stateflow-and-sharedflow
Event Aggregator,Behavioral,Flutter,event bus aggregator decouple communication stream publish subscribe dart,Centralize event communication between decoupled components through a shared event stream,Widgets passing callbacks deep through the tree | Direct references between unrelated blocs,Cross-feature notifications | Analytics dispatching | Theme/locale changes | Auth state broadcasting,EventAggregator → Stream → Subscriber,"// Passing callbacks 5 levels deep\nMyApp(\n  onCartUpdate: (count) {\n    badgeWidget.update(count);\n    toolbarWidget.refresh();\n  },\n)","class EventBus {\n  final _controller = StreamController<AppEvent>.broadcast();\n  Stream<T> on<T extends AppEvent>() => _controller.stream.whereType<T>();\n  void fire(AppEvent event) => _controller.add(event);\n  void dispose() => _controller.close();\n}\n// Subscribe: eventBus.on<CartUpdated>().listen((e) => ...);",Use StreamController.broadcast() for multi-listener events. Register in DI (get_it). Prefer BLoC-to-BLoC communication via providers for most cases.,https://pub.dev/packages/event_bus
Builder,Creational,Flutter,builder telescoping constructor optional parameters dart configuration,Construct complex objects step by step allowing different representations,Widget constructors with many optional parameters | Deeply nested widget configuration,Complex form builders | Theme configuration | Chart/graph setup | Animation configuration,Builder → Product,"CustomChart(\n  title: 'Sales',\n  xAxis: Axis(label: 'Month', min: 0, max: 12),\n  yAxis: Axis(label: 'Revenue', min: 0, max: 100000),\n  legend: Legend(position: LegendPosition.bottom),\n  gridLines: true,\n  animate: true,\n  duration: Duration(milliseconds: 500),\n  // 15+ params\n)","class ChartBuilder {\n  String _title = '';\n  Axis? _xAxis;\n  bool _animate = false;\n  ChartBuilder title(String v) { _title = v; return this; }\n  ChartBuilder xAxis(Axis v) { _xAxis = v; return this; }\n  ChartBuilder animate({Duration duration = const Duration(milliseconds: 300)}) {\n    _animate = true; return this;\n  }\n  CustomChart build() => CustomChart._(_title, _xAxis, _animate);\n}",Dart named parameters with defaults often eliminate Builder need. Use Builder when construction has validation steps or complex defaults.,https://refactoring.guru/design-patterns/builder
Singleton,Creational,iOS,singleton global state shared instance single object swift,Ensure a class has only one instance and provide global access to it,Multiple instances of manager classes | Global mutable state with inconsistent access patterns,App configuration | Keychain wrapper | Analytics tracker | Network session,Singleton → Instance,"class NetworkManager {\n  static var shared: NetworkManager?\n  static func getInstance() -> NetworkManager {\n    if shared == nil { shared = NetworkManager() }\n    return shared!\n  }\n}","// Modern Swift singleton\nclass NetworkManager {\n  static let shared = NetworkManager()\n  private init() {}\n}\n// Better: use DI container\nprotocol NetworkManaging { ... }\nclass NetworkManager: NetworkManaging { ... }\n// Register in DI: container.register(NetworkManaging.self) { NetworkManager() }",Prefer DI over singletons for testability. If using singleton use static let (thread-safe in Swift). Never use force unwrap for shared instances.,https://refactoring.guru/design-patterns/singleton
Adapter,Structural,iOS,adapter wrapper interface incompatible api response mapping swift convert,Convert the interface of a class into another interface clients expect,Manual mapping code scattered across ViewModels | Incompatible third-party SDK types,Mapping Codable DTOs to domain models | Wrapping legacy Obj-C APIs | Converting between library types,Target → Adapter → Adaptee,"// Scattered everywhere\nlet user = User(\n  name: response.full_name ?? """",\n  email: response.email_address ?? """",\n  avatar: URL(string: response.profile_image_url ?? """")\n)","struct UserMapper {\n  static func toDomain(_ dto: UserDTO) -> User {\n    User(\n      name: dto.full_name ?? """",\n      email: dto.email_address ?? """",\n      avatar: URL(string: dto.profile_image_url ?? """")\n    )\n  }\n}",Use extensions on DTOs for concise mapping (extension UserDTO { var asDomain: User { ... } }). Place mappers at Clean Architecture layer boundaries.,https://refactoring.guru/design-patterns/adapter
Repository,Domain,Flutter,repository data source abstraction layer clean architecture dart,Abstract data access behind a clean interface hiding data source details,Widget or bloc directly calling HTTP client or database | Data source logic in presentation layer,Any app with API + local storage | Offline-first apps | Data caching,Repository → DataSource,"class UserBloc {\n  Future<User> getUser(String id) async {\n    final response = await http.get(Uri.parse('$baseUrl/users/$id'));\n    final user = User.fromJson(jsonDecode(response.body));\n    await box.put(id, user);\n    return user;\n  }\n}","abstract class UserRepository {\n  Future<User> getUser(String id);\n}\nclass UserRepositoryImpl implements UserRepository {\n  final UserRemoteDataSource remote;\n  final UserLocalDataSource local;\n  @override\n  Future<User> getUser(String id) async {\n    final cached = await local.getUser(id);\n    if (cached != null) return cached;\n    final user = await remote.getUser(id);\n    await local.save(user);\n    return user;\n  }\n}",Use riverpod or get_it to inject repositories. Return domain models not JSON maps. Use streams for reactive local data observation.,https://pub.dev/packages/riverpod
Dependency Injection,Creational,iOS,dependency injection di container constructor inject scope swift,Provide dependencies to objects rather than having them create their own,Manual object creation with hard-coded dependencies | Singletons everywhere preventing testing,ViewModels with service dependencies | Repository injection | Swapping mocks for tests,Container → Protocol → Implementation,"class UserViewModel: ObservableObject {\n  private let repo = UserRepositoryImpl(\n    api: URLSession.shared,\n    db: CoreDataStack.shared.context\n  ) // hard-coded\n}","// Protocol-based DI\nclass UserViewModel: ObservableObject {\n  private let repo: UserRepository\n  init(repo: UserRepository) { self.repo = repo }\n}\n// In app: UserViewModel(repo: UserRepositoryImpl(...))\n// In test: UserViewModel(repo: MockUserRepository())",Swift has no standard DI framework. Use constructor injection + protocols. For larger apps consider Swinject or Factory. SwiftUI @Environment is limited DI.,https://github.com/hmlongco/Factory
God Class Extract,Refactoring,Android,god class large class extract refactor single responsibility bloated,Break apart classes that do too much by extracting focused collaborators,Class with 500+ lines | Class with 10+ dependencies | Class handling unrelated responsibilities,ViewModels doing network + caching + formatting | Activities with mixed concerns | Utility classes with unrelated methods,GodClass → Extracted focused classes,"@HiltViewModel\nclass HomeViewModel @Inject constructor(\n  private val api: Api,\n  private val db: AppDatabase,\n  private val prefs: SharedPreferences,\n  private val analytics: Analytics,\n  private val formatter: DateFormatter,\n  private val imageLoader: ImageLoader,\n  private val notificationManager: NotificationManager,\n  private val locationManager: LocationManager\n) : ViewModel() {\n  // 800 lines handling products, user, location, notifications, analytics\n}","// Split into focused use cases\n@HiltViewModel\nclass HomeViewModel @Inject constructor(\n  private val getProducts: GetProductsUseCase,\n  private val getUserProfile: GetUserProfileUseCase,\n  private val trackScreen: TrackScreenUseCase\n) : ViewModel() {\n  // 100 lines coordinating use cases\n}\nclass GetProductsUseCase @Inject constructor(\n  private val repo: ProductRepository\n) { suspend operator fun invoke(): List<Product> = repo.getProducts() }",If a ViewModel has more than 5 dependencies it likely does too much. Extract Use Cases. Each class should have one reason to change (SRP).,https://refactoring.guru/refactoring/smells/large-class
God Class Extract,Refactoring,iOS,god class massive viewcontroller extract refactor single responsibility bloated swift,Break apart massive view controllers or classes that handle too many responsibilities,ViewController with 1000+ lines | Class managing UI + networking + data + navigation,Massive ViewControllers | Monolithic ViewModels | Swiss-army-knife managers,MassiveClass → Focused collaborators,"class ProfileVC: UIViewController {\n  // Handles: UI layout, API calls, CoreData, image picking,\n  // form validation, navigation, analytics, notifications\n  // 1200 lines\n}","class ProfileVC: UIViewController {\n  private let viewModel: ProfileViewModel\n  private let coordinator: ProfileCoordinator\n  // Only handles: binding VM to UI, user interactions → VM/coordinator\n  // 150 lines\n}\nclass ProfileViewModel: ObservableObject { /* state + business logic */ }\nclass ProfileCoordinator { /* navigation */ }",The Massive ViewController smell is iOS-specific. Extract: Coordinator (navigation) + ViewModel (state) + DataSource (table/collection). Aim for <200 lines per VC.,https://refactoring.guru/refactoring/smells/large-class
Feature Envy Refactor,Refactoring,All,feature envy move method wrong class responsibility,Move methods to the class whose data they primarily use when a method accesses another object's data more than its own,Method that calls 5+ getters on another object | Logic that belongs with the data it operates on,Formatting methods operating on model data | Calculations using another class's fields | Validation of external object state,EnvyClass → method moves to → DataClass,"class OrderPresenter {\n  fun formatOrderSummary(order: Order): String {\n    val subtotal = order.items.sumOf { it.price * it.quantity }\n    val tax = subtotal * order.taxRate\n    val shipping = if (order.weight > 10) order.heavyShippingRate else order.standardRate\n    val discount = order.coupon?.discountPercent?.let { subtotal * it / 100 } ?: 0.0\n    return ""Total: ${subtotal + tax + shipping - discount}""\n  } // accesses Order 8 times, self 0 times\n}","class Order {\n  fun calculateTotal(): Double {\n    val subtotal = items.sumOf { it.price * it.quantity }\n    val tax = subtotal * taxRate\n    val shipping = if (weight > 10) heavyShippingRate else standardRate\n    val discount = coupon?.discountPercent?.let { subtotal * it / 100 } ?: 0.0\n    return subtotal + tax + shipping - discount\n  }\n}\nclass OrderPresenter {\n  fun formatOrderSummary(order: Order) = ""Total: ${order.calculateTotal()}""\n}",Count how many times a method accesses self vs another object. If it uses another object more move the logic there. Keeps data and behavior together.,https://refactoring.guru/refactoring/smells/feature-envy
Callback Hell Refactor,Refactoring,Android,callback hell nested pyramid async listener cleanup coroutines,Replace deeply nested callbacks with structured concurrency or reactive chains,3+ levels of nested callbacks | Pyramid-shaped indentation | Chained listeners with error handling at each level,Network call chains | Database operations after API calls | Sequential async operations | File operations,Nested callbacks → Coroutines/Flow,"fun loadUserData(userId: String, callback: (Result<UserData>) -> Unit) {\n  api.getUser(userId) { userResult ->\n    if (userResult.isSuccess) {\n      api.getOrders(userId) { ordersResult ->\n        if (ordersResult.isSuccess) {\n          api.getRecommendations(userId) { recsResult ->\n            if (recsResult.isSuccess) {\n              callback(Result.success(UserData(userResult, ordersResult, recsResult)))\n            } else callback(Result.failure(recsResult.exceptionOrNull()!!))\n          }\n        } else callback(Result.failure(ordersResult.exceptionOrNull()!!))\n      }\n    } else callback(Result.failure(userResult.exceptionOrNull()!!))\n  }\n}","suspend fun loadUserData(userId: String): UserData {\n  val user = api.getUser(userId)\n  val orders = api.getOrders(userId)\n  val recs = api.getRecommendations(userId)\n  return UserData(user, orders, recs)\n}\n// Or parallel: coroutineScope {\n//   val user = async { api.getUser(userId) }\n//   val orders = async { api.getOrders(userId) }\n//   UserData(user.await(), orders.await())\n// }",Kotlin coroutines eliminate callback hell. Use suspend functions for sequential. Use async/await for parallel. Use Flow for streams. Never nest callbacks in modern Android.,https://developer.android.com/kotlin/coroutines
Callback Hell Refactor,Refactoring,iOS,callback hell nested pyramid async completion handler closure swift,Replace deeply nested completion handlers with Swift async/await,3+ levels of nested closures | Pyramid of doom | Chained completion handlers,Sequential API calls | Auth then fetch flows | Multi-step async operations,Nested closures → async/await,"func loadUserData(userId: String, completion: @escaping (Result<UserData, Error>) -> Void) {\n  api.getUser(userId) { userResult in\n    switch userResult {\n    case .success(let user):\n      self.api.getOrders(userId) { ordersResult in\n        switch ordersResult {\n        case .success(let orders):\n          self.api.getRecs(userId) { recsResult in\n            // deeper and deeper...\n          }\n        case .failure(let error): completion(.failure(error))\n        }\n      }\n    case .failure(let error): completion(.failure(error))\n    }\n  }\n}","func loadUserData(userId: String) async throws -> UserData {\n  let user = try await api.getUser(userId)\n  let orders = try await api.getOrders(userId)\n  let recs = try await api.getRecs(userId)\n  return UserData(user: user, orders: orders, recs: recs)\n}\n// Parallel: async let user = api.getUser(id)\n//           async let orders = api.getOrders(id)",Swift async/await (iOS 15+) eliminates completion handler pyramids. Use async let for parallel. Use TaskGroup for dynamic concurrency.,https://developer.apple.com/documentation/swift/concurrency
Callback Hell Refactor,Refactoring,Flutter,callback hell nested pyramid async future then chained dart,Replace deeply nested .then() chains with async/await,3+ levels of nested .then() | Chained futures with error handling | Pyramid of closures,Sequential API calls | Database after network | Multi-step operations,Nested .then() → async/await,"void loadUserData(String userId) {\n  api.getUser(userId).then((user) {\n    api.getOrders(userId).then((orders) {\n      api.getRecs(userId).then((recs) {\n        setState(() { data = UserData(user, orders, recs); });\n      }).catchError((e) => handleError(e));\n    }).catchError((e) => handleError(e));\n  }).catchError((e) => handleError(e));\n}","Future<UserData> loadUserData(String userId) async {\n  final user = await api.getUser(userId);\n  final orders = await api.getOrders(userId);\n  final recs = await api.getRecs(userId);\n  return UserData(user: user, orders: orders, recs: recs);\n}\n// Parallel: final results = await Future.wait([getUser(id), getOrders(id)]);",Dart async/await is cleaner than .then() chains. Use Future.wait() for parallel. Use try/catch instead of .catchError(). Combine with BLoC for state management.,https://dart.dev/codelabs/async-await
Shotgun Surgery Refactor,Refactoring,All,shotgun surgery scattered change feature spread multiple classes,Consolidate logic that forces changes across many files into a cohesive module,Adding a feature requires touching 10+ files | Every change to one concept ripples across many classes,Adding a new user field requires changes in DTO + mapper + entity + dao + repo + usecase + VM + UI | Feature flag checks scattered everywhere,Scattered classes → Cohesive module,"// Adding ""phone"" field requires changing:\n// UserDto.kt - add field\n// UserEntity.kt - add column\n// UserMapper.kt - add mapping\n// UserDao.kt - update query\n// UserRepository.kt - pass through\n// UserUseCase.kt - pass through\n// UserViewModel.kt - expose to UI\n// UserScreen.kt - display field\n// 8 files for 1 field!","// 1. Use code generation to reduce boilerplate\n// 2. Consolidate with sealed domain model\ndata class User(\n  val id: String,\n  val name: String,\n  val phone: String // add once\n)\n// Use SqlDelight/Room entity = domain model for simple cases\n// Use @Serializable for auto DTO mapping\n// ViewModel exposes User directly for display-only fields",Some shotgun surgery is unavoidable in Clean Architecture. Minimize it by: using code generation (Room/SqlDelight) and reducing unnecessary layers. Not every app needs Use Cases.,https://refactoring.guru/refactoring/smells/shotgun-surgery
Divergent Change Refactor,Refactoring,All,divergent change multiple reasons change single class responsibilities,Split classes that change for multiple unrelated reasons into focused classes,One class modified for every type of change | Class changes whenever any feature changes,Repository handling caching + networking + mapping | ViewModel managing navigation + state + formatting,Fat class → Single-responsibility classes,"class UserRepository {\n  // Changes when: API changes, caching strategy changes,\n  // mapping logic changes, error handling changes\n  fun getUser(id: String): User {\n    val cached = cache.get(id) // caching concern\n    if (cached != null && !isExpired(cached)) return cached.toUser() // mapping concern\n    val response = try { api.getUser(id) } catch (e: Exception) { handleNetworkError(e) } // error concern\n    cache.put(id, response) // caching concern\n    return response.toUser() // mapping concern\n  }\n}","class UserRemoteDataSource(private val api: UserApi) {\n  suspend fun getUser(id: String): UserDto = api.getUser(id)\n}\nclass UserLocalDataSource(private val cache: UserCache) {\n  fun getUser(id: String): UserEntity? = cache.get(id)\n  fun save(user: UserEntity) = cache.put(user.id, user)\n}\nclass UserMapper {\n  fun toDomain(dto: UserDto): User = ...\n}\nclass UserRepositoryImpl(\n  private val remote: UserRemoteDataSource,\n  private val local: UserLocalDataSource,\n  private val mapper: UserMapper\n) : UserRepository { ... }",If a class has multiple unrelated reasons to change split it. Each extracted class changes for exactly one reason. This is SRP applied to data layer.,https://refactoring.guru/refactoring/smells/divergent-change
Long Parameter List Refactor,Refactoring,All,long parameter list many arguments method signature refactor,Reduce method parameter count by grouping related parameters into objects,Methods with 5+ parameters | Boolean flags controlling behavior | Parameters that always travel together,API call builders | Event tracking methods | Configuration functions | Factory methods with many options,Long params → Parameter Object or Builder,"fun createNotification(\n  title: String,\n  body: String,\n  channelId: String,\n  priority: Int,\n  icon: Int,\n  color: Int,\n  autoCancel: Boolean,\n  vibrate: Boolean,\n  sound: Uri?,\n  actions: List<Action>,\n  pendingIntent: PendingIntent\n) { ... }","data class NotificationConfig(\n  val title: String,\n  val body: String,\n  val channelId: String,\n  val priority: Int = NotificationCompat.PRIORITY_DEFAULT,\n  val icon: Int = R.drawable.ic_notification,\n  val autoCancel: Boolean = true,\n  val vibrate: Boolean = true,\n  val sound: Uri? = null,\n  val actions: List<Action> = emptyList()\n)\nfun createNotification(config: NotificationConfig, intent: PendingIntent) { ... }",Group related parameters into data classes. Use Kotlin default parameters to reduce required args. Max 3-4 params per method is a good rule of thumb.,https://refactoring.guru/refactoring/smells/long-parameter-list
Boolean Blindness Refactor,Refactoring,All,boolean blindness flag parameter enum sealed replace clarity,Replace boolean parameters with enums or sealed types for self-documenting code,Methods with boolean flags that are unclear at call site | Multiple boolean parameters,Toggle visibility modes | API call options | UI state flags | Feature switches,Boolean params → Enum/Sealed type,"// What do these booleans mean at the call site?\nfun loadData(forceRefresh: Boolean, includeDeleted: Boolean, compress: Boolean)\nloadData(true, false, true) // unreadable","enum class RefreshPolicy { CACHE_FIRST, FORCE_REFRESH }\nenum class DeletedFilter { INCLUDE, EXCLUDE }\nenum class Compression { ENABLED, DISABLED }\nfun loadData(\n  refresh: RefreshPolicy = RefreshPolicy.CACHE_FIRST,\n  deleted: DeletedFilter = DeletedFilter.EXCLUDE,\n  compression: Compression = Compression.DISABLED\n)\nloadData(refresh = RefreshPolicy.FORCE_REFRESH, compression = Compression.ENABLED)",Named boolean params in Kotlin/Swift help but enums are clearer. If a boolean controls behavior branching it is likely a Strategy in disguise.,https://refactoring.guru/refactoring/smells/boolean-blindness
Lazy Initialization,Creational,Android,lazy initialization deferred creation expensive startup performance,Defer expensive object creation until first use to improve startup time,Heavy objects created in Application.onCreate or Activity.onCreate slowing startup | Eager initialization of rarely-used features,Database initialization | Analytics setup | Feature module loading | Image loader configuration,Lazy → ValueHolder → ExpensiveObject,"class MyApp : Application() {\n  lateinit var db: AppDatabase\n  lateinit var analytics: Analytics\n  lateinit var imageLoader: ImageLoader\n  override fun onCreate() {\n    super.onCreate()\n    db = Room.databaseBuilder(this, AppDatabase::class.java, ""db"").build()\n    analytics = Analytics.create(this, KEY)\n    imageLoader = ImageLoader.Builder(this).build()\n    // 500ms+ added to startup\n  }\n}","class MyApp : Application() {\n  val db by lazy { Room.databaseBuilder(this, AppDatabase::class.java, ""db"").build() }\n  val analytics by lazy { Analytics.create(this, KEY) }\n  val imageLoader by lazy { ImageLoader.Builder(this).build() }\n  override fun onCreate() {\n    super.onCreate()\n    // Fast startup — objects created on first access\n  }\n}",Kotlin by lazy is thread-safe by default. Use LazyThreadSafetyMode.NONE if accessed only from main thread. With Hilt use @Inject + Lazy<T> for deferred injection.,https://developer.android.com/topic/performance/vitals/launch-time
Lazy Initialization,Creational,iOS,lazy initialization deferred creation expensive startup performance swift,Defer expensive object creation until first use,Heavy objects created in init or application didFinishLaunching | Eager setup of rarely-used services,CoreData stack | Analytics | Feature modules | Image processing pipeline,lazy var → Deferred creation,"class AppDelegate: UIApplicationDelegate {\n  var db: CoreDataStack!\n  var analytics: Analytics!\n  func application(_ app: UIApplication, didFinishLaunchingWithOptions opts: ...) -> Bool {\n    db = CoreDataStack()\n    analytics = Analytics(key: KEY)\n    // slow startup\n    return true\n  }\n}","class AppDelegate: UIApplicationDelegate {\n  lazy var db = CoreDataStack()\n  lazy var analytics = Analytics(key: KEY)\n  func application(_ app: UIApplication, didFinishLaunchingWithOptions opts: ...) -> Bool {\n    // fast startup — created on first access\n    return true\n  }\n}",Swift lazy var is not thread-safe (unlike Kotlin). For thread-safe lazy use DispatchQueue.once or static let. Use lazy for main-thread-only properties.,https://developer.apple.com/documentation/xcode/reducing-your-app-s-launch-time
Iterator,Behavioral,Android,iterator traversal collection sequence cursor custom iterable,Provide sequential access to collection elements without exposing the underlying structure,Direct index-based loops tightly coupled to internal data structure | Manual cursor management for paginated data,Paginated API results | Database cursor wrappers | Custom tree/graph traversal | Infinite scroll data sources,Iterable → Iterator → ConcreteIterator,"class ChatRepo {\n  private val pages = mutableListOf<List<Message>>()\n  fun getMessage(index: Int): Message {\n    val pageIndex = index / PAGE_SIZE\n    val itemIndex = index % PAGE_SIZE\n    if (pageIndex >= pages.size) loadPage(pageIndex)\n    return pages[pageIndex][itemIndex]\n  } // caller must manage indices\n}","class MessageIterator(\n  private val repo: ChatRepo\n) : Iterator<Message> {\n  private var cursor = 0\n  private var currentPage: List<Message>? = null\n  override fun hasNext(): Boolean = repo.hasMore(cursor)\n  override fun next(): Message {\n    if (currentPage == null || cursor % PAGE_SIZE == 0) currentPage = repo.loadPage(cursor / PAGE_SIZE)\n    return currentPage!![cursor++ % PAGE_SIZE]\n  }\n}\n// Usage: repo.messages().forEach { display(it) }",Kotlin Sequence and Flow are built-in lazy iterators. Use Paging 3 library for paginated iteration in Android. Prefer Flow over custom iterators.,https://refactoring.guru/design-patterns/iterator
Iterator,Behavioral,iOS,iterator traversal collection sequence cursor custom iterable swift,Provide sequential access to collection elements without exposing the underlying structure,Direct array index loops coupled to data structure | Manual pagination cursor management,Paginated API results | Core Data fetch batching | Custom collection traversal | Infinite scroll,Sequence → IteratorProtocol,"class ChatRepo {\n  private var pages: [[Message]] = []\n  func message(at index: Int) -> Message {\n    let page = index / pageSize\n    if page >= pages.count { loadPage(page) }\n    return pages[page][index % pageSize]\n  } // caller manages indices\n}","struct MessageIterator: IteratorProtocol {\n  private let repo: ChatRepo\n  private var cursor = 0\n  mutating func next() -> Message? {\n    guard repo.hasMore(cursor) else { return nil }\n    defer { cursor += 1 }\n    return repo.message(at: cursor)\n  }\n}\nstruct Messages: Sequence {\n  func makeIterator() -> MessageIterator { ... }\n}\n// Usage: for message in repo.messages { display(message) }",Swift IteratorProtocol + Sequence enables for-in loops. AsyncSequence is the async iterator for Swift concurrency. Use for paginated data streams.,https://developer.apple.com/documentation/swift/iteratorprotocol
Iterator,Behavioral,Flutter,iterator traversal collection sequence cursor custom iterable dart,Provide sequential access to collection elements without exposing the underlying structure,Direct list index access coupled to data structure | Manual page tracking for infinite scroll,Paginated API results | Lazy-loaded collections | Custom data structure traversal,Iterable → Iterator,"class ChatRepo {\n  final _pages = <List<Message>>[];\n  Message getMessage(int index) {\n    final page = index ~/ pageSize;\n    if (page >= _pages.length) _loadPage(page);\n    return _pages[page][index % pageSize];\n  } // caller manages indices\n}","class MessageIterable extends Iterable<Message> {\n  final ChatRepo repo;\n  MessageIterable(this.repo);\n  @override\n  Iterator<Message> get iterator => MessageIterator(repo);\n}\nclass MessageIterator implements Iterator<Message> {\n  final ChatRepo repo;\n  int _cursor = -1;\n  @override\n  Message get current => repo.getMessage(_cursor);\n  @override\n  bool moveNext() => repo.hasMore(++_cursor);\n}\n// Usage: for (final msg in repo.messages) { display(msg); }",Dart Iterable/Iterator is built-in. Use Stream for async iteration. Use sync*/async* generators for lazy sequences. Prefer Stream over custom iterators.,https://dart.dev/guides/language/language-tour#generators
Interpreter,Behavioral,All,interpreter grammar expression parse evaluate DSL rule engine,Define a grammar and build an interpreter to evaluate sentences in that language,Hard-coded business rules with nested conditionals | String parsing with regex spaghetti | Complex filter expressions built manually,Search query parsing | Rule engines | Expression evaluators | DSL for configuration | Filter builders,AbstractExpression → TerminalExpression → NonterminalExpression → Context,"fun evaluate(rule: String, user: User): Boolean {\n  if (rule.contains(""age>"")) {\n    val age = rule.substringAfter(""age>"").substringBefore(""&&"").trim().toInt()\n    if (user.age <= age) return false\n  }\n  if (rule.contains(""country=="")) {\n    val country = rule.substringAfter(""country=="").substringBefore(""&&"").trim()\n    if (user.country != country) return false\n  }\n  return true // fragile regex-based parsing\n}","interface Expression {\n  fun interpret(context: User): Boolean\n}\nclass AgeGreaterThan(private val age: Int) : Expression {\n  override fun interpret(context: User) = context.age > age\n}\nclass CountryEquals(private val country: String) : Expression {\n  override fun interpret(context: User) = context.country == country\n}\nclass And(private val left: Expression, private val right: Expression) : Expression {\n  override fun interpret(context: User) = left.interpret(context) && right.interpret(context)\n}\n// Usage: And(AgeGreaterThan(18), CountryEquals(""US"")).interpret(user)",Interpreter is heavy — prefer Strategy or Specification for simpler cases. Use only for actual DSL/expression parsing. Consider ANTLR for complex grammars.,https://refactoring.guru/design-patterns/interpreter
Use Case,Domain,Android,use case interactor business logic clean architecture single responsibility,Encapsulate a single business operation into a reusable independently testable class,Business logic mixed into ViewModel | ViewModel calling repositories directly with complex orchestration,Any operation shared across ViewModels | Complex business rules | Operations requiring multiple repositories,UseCase → Repository → Domain Model,"@HiltViewModel\nclass OrderViewModel @Inject constructor(\n  private val orderRepo: OrderRepository,\n  private val userRepo: UserRepository,\n  private val paymentRepo: PaymentRepository,\n  private val analyticsRepo: AnalyticsRepository\n) : ViewModel() {\n  fun placeOrder(cart: Cart) {\n    val user = userRepo.getCurrent()\n    val validated = validateCart(cart, user)\n    val payment = paymentRepo.charge(validated.total)\n    orderRepo.create(validated, payment)\n    analyticsRepo.trackPurchase(validated.total)\n  } // repeated in RetryOrderVM, ReorderVM\n}","class PlaceOrderUseCase @Inject constructor(\n  private val orderRepo: OrderRepository,\n  private val userRepo: UserRepository,\n  private val paymentRepo: PaymentRepository,\n  private val analytics: AnalyticsRepository\n) {\n  suspend operator fun invoke(cart: Cart): Result<Order> {\n    val user = userRepo.getCurrent()\n    val validated = validateCart(cart, user)\n    val payment = paymentRepo.charge(validated.total)\n    val order = orderRepo.create(validated, payment)\n    analytics.trackPurchase(validated.total)\n    return Result.success(order)\n  }\n}\n// ViewModel: placeOrder(cart) in any VM",Use operator fun invoke() for clean call syntax. Each UseCase does one thing. Use @Inject constructor for Hilt. Return Result or Flow.,https://developer.android.com/topic/architecture/domain-layer
Use Case,Domain,iOS,use case interactor business logic clean architecture swift single responsibility,Encapsulate a single business operation into a reusable testable class,Business logic mixed into ViewModel | Duplicated orchestration logic across multiple ViewModels,Shared business operations | Complex multi-repository coordination | Testable business rules,UseCase → Repository → Domain Model,"class OrderViewModel: ObservableObject {\n  let orderRepo: OrderRepository\n  let userRepo: UserRepository\n  let paymentRepo: PaymentRepository\n  func placeOrder(cart: Cart) async throws {\n    let user = try await userRepo.getCurrent()\n    let payment = try await paymentRepo.charge(cart.total)\n    try await orderRepo.create(cart, payment)\n  } // duplicated in ReorderVM, RetryVM\n}","protocol PlaceOrderUseCase {\n  func execute(cart: Cart) async throws -> Order\n}\nclass PlaceOrderUseCaseImpl: PlaceOrderUseCase {\n  private let orderRepo: OrderRepository\n  private let userRepo: UserRepository\n  private let paymentRepo: PaymentRepository\n  func execute(cart: Cart) async throws -> Order {\n    let user = try await userRepo.getCurrent()\n    let payment = try await paymentRepo.charge(cart.total)\n    return try await orderRepo.create(cart, payment)\n  }\n}\n// ViewModel: let order = try await placeOrder.execute(cart: cart)",Protocol-based UseCases enable easy mocking. callAsFunction() in Swift enables placeOrder(cart) syntax similar to Kotlin invoke().,https://clean-swift.com
Use Case,Domain,Flutter,use case interactor business logic clean architecture dart single responsibility,Encapsulate a single business operation into a reusable testable class,Business logic mixed into Bloc/Cubit | Duplicated orchestration across multiple blocs,Shared business operations | Complex multi-repository coordination | Testable business rules,UseCase → Repository → Domain Model,"class OrderCubit extends Cubit<OrderState> {\n  final orderRepo = OrderRepositoryImpl();\n  final userRepo = UserRepositoryImpl();\n  final paymentRepo = PaymentRepositoryImpl();\n  Future<void> placeOrder(Cart cart) async {\n    final user = await userRepo.getCurrent();\n    final payment = await paymentRepo.charge(cart.total);\n    await orderRepo.create(cart, payment);\n  } // duplicated in ReorderCubit\n}","abstract class UseCase<T, P> {\n  Future<T> call(P params);\n}\nclass PlaceOrderUseCase implements UseCase<Order, Cart> {\n  final OrderRepository orderRepo;\n  final UserRepository userRepo;\n  final PaymentRepository paymentRepo;\n  PlaceOrderUseCase({required this.orderRepo, required this.userRepo, required this.paymentRepo});\n  @override\n  Future<Order> call(Cart cart) async {\n    final user = await userRepo.getCurrent();\n    final payment = await paymentRepo.charge(cart.total);\n    return orderRepo.create(cart, payment);\n  }\n}\n// Bloc: final order = await placeOrder(cart);",Use Dart call() method for clean invocation. Base UseCase class with generics for consistency. Inject via get_it or riverpod.,https://resocoder.com/flutter-clean-architecture
MVI,Architectural,Android,mvi model view intent unidirectional state reducer event,Implement unidirectional data flow where UI events become intents processed by a reducer into new states,Scattered mutable state | Multiple LiveData/StateFlow emissions causing inconsistent UI | Event handling mixed with state updates,Complex screens with many interactions | Forms with validation | Screens requiring undo | Multi-source state updates,View → Intent → Reducer → State → View,"class ProfileViewModel : ViewModel() {\n  private val _name = MutableStateFlow("""")\n  private val _email = MutableStateFlow("""")\n  private val _isLoading = MutableStateFlow(false)\n  private val _error = MutableStateFlow<String?>(null)\n  // 4 separate flows → UI can see inconsistent combinations\n  fun loadProfile() { _isLoading.value = true; /* ... */ }\n  fun updateName(name: String) { _name.value = name }\n}","data class ProfileState(\n  val name: String = """",\n  val email: String = """",\n  val isLoading: Boolean = false,\n  val error: String? = null\n)\nsealed class ProfileIntent {\n  object Load : ProfileIntent()\n  data class UpdateName(val name: String) : ProfileIntent()\n}\n@HiltViewModel\nclass ProfileViewModel @Inject constructor(private val repo: UserRepo) : ViewModel() {\n  private val _state = MutableStateFlow(ProfileState())\n  val state = _state.asStateFlow()\n  fun onIntent(intent: ProfileIntent) {\n    when (intent) {\n      is ProfileIntent.Load -> loadProfile()\n      is ProfileIntent.UpdateName -> _state.update { it.copy(name = intent.name) }\n    }\n  }\n}",MVI guarantees single source of truth via single state object. Use copy() for immutable updates. Combine with Orbit MVI or custom reducer. Best for complex UIs.,https://orbit-mvi.org/
MVI,Architectural,Flutter,mvi model view intent unidirectional state bloc cubit event dart,Implement unidirectional data flow where UI events become intents processed into new states,Multiple setState() calls causing inconsistent UI | State scattered across StatefulWidgets | No single source of truth,Complex screens with many interactions | Forms | Real-time data screens,View → Event → Bloc → State → View,"class ProfilePage extends StatefulWidget {\n  @override\n  State createState() => _State();\n}\nclass _State extends State<ProfilePage> {\n  String name = '';\n  String email = '';\n  bool isLoading = false;\n  String? error;\n  // 4 separate variables, setState scattered everywhere\n}","@freezed\nclass ProfileState with _$ProfileState {\n  const factory ProfileState({@Default('') String name, @Default('') String email, @Default(false) bool isLoading, String? error}) = _ProfileState;\n}\nsealed class ProfileEvent {}\nclass LoadProfile extends ProfileEvent {}\nclass UpdateName extends ProfileEvent { final String name; UpdateName(this.name); }\nclass ProfileBloc extends Bloc<ProfileEvent, ProfileState> {\n  ProfileBloc(this.repo) : super(const ProfileState()) {\n    on<LoadProfile>(_onLoad);\n    on<UpdateName>((e, emit) => emit(state.copyWith(name: e.name)));\n  }\n}",BLoC is Flutter's MVI. Use freezed for immutable state. Events = Intents. Single state object = single source of truth. Best for complex screens.,https://bloclibrary.dev/
Result Wrapper,Domain,Android,result wrapper either success failure error handling sealed,Wrap operation outcomes in a sealed type to enforce explicit error handling,Nullable returns where null means error | Thrown exceptions as control flow | Callbacks with separate success/error paths,API responses | Database operations | Validation results | Any fallible operation,Result → Success → Failure,"suspend fun getUser(id: String): User? {\n  return try {\n    api.fetchUser(id).toUser()\n  } catch (e: Exception) {\n    null // lost error info\n  }\n}\n// Caller: val user = getUser(id) ?: /* what went wrong? */","sealed class Result<out T> {\n  data class Success<T>(val data: T) : Result<T>()\n  data class Error(val exception: Throwable, val message: String? = null) : Result<Nothing>()\n}\nsuspend fun getUser(id: String): Result<User> {\n  return try {\n    Result.Success(api.fetchUser(id).toUser())\n  } catch (e: Exception) {\n    Result.Error(e, ""Failed to load user"")\n  }\n}\n// Caller: when (val result = getUser(id)) {\n//   is Result.Success -> show(result.data)\n//   is Result.Error -> showError(result.message)\n// }",Kotlin sealed classes make Result exhaustive with when. Use kotlin.Result for simple cases. Custom sealed Result for richer error types. Never use exceptions for control flow.,https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/
Result Wrapper,Domain,iOS,result wrapper either success failure error handling swift,Wrap operation outcomes to enforce explicit error handling,Optional returns losing error context | Thrown errors without typed information | Completion handlers with optional error,API responses | Validation | Database operations | Any fallible async work,Result → success → failure,"func getUser(id: String) async -> User? {\n  do {\n    return try await api.fetchUser(id).toUser()\n  } catch {\n    return nil // error info lost\n  }\n}","enum AppError: Error {\n  case network(underlying: Error)\n  case notFound\n  case unauthorized\n}\nfunc getUser(id: String) async -> Result<User, AppError> {\n  do {\n    let dto = try await api.fetchUser(id)\n    return .success(dto.toUser())\n  } catch {\n    return .failure(.network(underlying: error))\n  }\n}\n// switch result { case .success(let user): ... case .failure(let error): ... }",Swift has built-in Result<Success Failure: Error>. Use typed errors for rich error handling. In Swift 6 use typed throws for even better error typing.,https://developer.apple.com/documentation/swift/result
Result Wrapper,Domain,Flutter,result wrapper either success failure error handling sealed dart,Wrap operation outcomes in a sealed type to enforce explicit error handling,Thrown exceptions as control flow | Nullable returns losing error context | try/catch everywhere,API responses | Form validation | Database operations | Any fallible operation,Result → Success → Failure,"Future<User?> getUser(String id) async {\n  try {\n    return await api.fetchUser(id).toUser();\n  } catch (e) {\n    return null; // error info lost\n  }\n}","sealed class Result<T> {}\nclass Success<T> extends Result<T> { final T data; Success(this.data); }\nclass Failure<T> extends Result<T> { final String message; final Exception? exception; Failure(this.message, [this.exception]); }\nFuture<Result<User>> getUser(String id) async {\n  try {\n    return Success(await api.fetchUser(id).toUser());\n  } catch (e) {\n    return Failure('Failed to load user', e as Exception?);\n  }\n}\n// Usage: switch (result) { case Success(:final data): ... case Failure(:final message): ... }",Use Dart 3 sealed classes and patterns for exhaustive matching. Or use fpdart Either for functional style. dartz package also provides Either.,https://pub.dev/packages/fpdart
Sealed UI State,Architectural,Android,sealed state ui loading error success empty screen state management,Model all possible screen states as a sealed hierarchy for exhaustive UI rendering,Multiple boolean flags (isLoading + isError + isEmpty) causing impossible state combinations,Any screen with async data loading | List screens | Detail screens | Form submissions,Sealed State → Loading → Success → Error → Empty,"class ProfileViewModel : ViewModel() {\n  val isLoading = MutableStateFlow(false)\n  val error = MutableStateFlow<String?>(null)\n  val user = MutableStateFlow<User?>(null)\n  val isEmpty = MutableStateFlow(false)\n  // Can be loading=true AND error!=null AND user!=null simultaneously!\n}","sealed class UiState<out T> {\n  object Loading : UiState<Nothing>()\n  data class Success<T>(val data: T) : UiState<T>()\n  data class Error(val message: String) : UiState<Nothing>()\n  object Empty : UiState<Nothing>()\n}\n@HiltViewModel\nclass ProfileViewModel @Inject constructor(repo: UserRepo) : ViewModel() {\n  val state: StateFlow<UiState<User>> = repo.getUser()\n    .map<User, UiState<User>> { UiState.Success(it) }\n    .catch { emit(UiState.Error(it.message ?: ""Unknown"")) }\n    .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), UiState.Loading)\n}",Sealed UiState prevents impossible states. When + Composable renders exhaustively. Generic UiState<T> is reusable. Combine with collectAsStateWithLifecycle().,https://developer.android.com/topic/architecture/ui-layer/stateholders
Sealed UI State,Architectural,iOS,sealed state ui loading error success empty screen state management swift,Model all possible screen states as an enum for exhaustive UI rendering,Multiple @Published booleans causing impossible state combinations | Scattered state checks in view,Any screen with async data loading | List/detail screens | Form submissions,Enum State → loading → success → error,"class ProfileViewModel: ObservableObject {\n  @Published var isLoading = false\n  @Published var error: String?\n  @Published var user: User?\n  // Can be loading + error + user all set simultaneously!\n}","enum ViewState<T> {\n  case loading\n  case success(T)\n  case error(String)\n  case empty\n}\nclass ProfileViewModel: ObservableObject {\n  @Published var state: ViewState<User> = .loading\n  func load() async {\n    state = .loading\n    do {\n      let user = try await repo.getUser()\n      state = .success(user)\n    } catch {\n      state = .error(error.localizedDescription)\n    }\n  }\n}\n// View: switch viewModel.state { case .loading: ProgressView() ... }",Swift enum with associated values is a natural sealed state. Use @ViewBuilder in SwiftUI for exhaustive rendering. Prevents impossible states.,https://developer.apple.com/documentation/swiftui/viewbuilder
Sealed UI State,Architectural,Flutter,sealed state ui loading error success empty screen state management dart,Model all possible screen states as a sealed class for exhaustive UI rendering,Multiple boolean fields in state causing impossible combinations | Scattered if/else in build(),Any screen with async data loading | BLoC states | Cubit states,Sealed State → Loading → Success → Error,"class ProfileState {\n  final bool isLoading;\n  final String? error;\n  final User? user;\n  final bool isEmpty;\n  // Can be loading + error + user simultaneously!\n}","sealed class ProfileState {}\nclass ProfileLoading extends ProfileState {}\nclass ProfileSuccess extends ProfileState { final User user; ProfileSuccess(this.user); }\nclass ProfileError extends ProfileState { final String message; ProfileError(this.message); }\nclass ProfileEmpty extends ProfileState {}\n// Widget: switch (state) {\n//   case ProfileLoading(): return CircularProgressIndicator();\n//   case ProfileSuccess(:final user): return UserCard(user);\n//   case ProfileError(:final message): return ErrorText(message);\n// }",Dart 3 sealed classes + switch patterns enable exhaustive matching. BLoC states should always be sealed. Use freezed for copyWith and equality.,https://bloclibrary.dev/
Service Locator,Creational,All,service locator registry global lookup anti-pattern dependency,Provide a global registry where objects can look up dependencies at runtime,Dependencies fetched from a global container at call sites | Hidden dependencies not visible in constructor,Legacy codebases migrating to DI | Plugin systems | Simple apps without full DI framework,ServiceLocator → Registry → Service,"class UserViewModel {\n  fun loadUser() {\n    val repo = ServiceLocator.get<UserRepository>() // hidden dependency\n    val analytics = ServiceLocator.get<Analytics>() // not in constructor\n    // Dependencies invisible from outside — breaks testing\n  }\n}","// Prefer constructor injection (DI)\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n  private val repo: UserRepository, // explicit dependency\n  private val analytics: Analytics  // visible and testable\n) : ViewModel() {\n  fun loadUser() { repo.getUser(); analytics.track() }\n}\n// In test: UserViewModel(FakeRepo(), FakeAnalytics())",Service Locator hides dependencies making testing and refactoring hard. Prefer constructor DI (Hilt/Koin/Swinject). Use SL only as migration step toward DI.,https://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/
Data Transfer Object,Structural,Android,dto data transfer object api response network model layer separation,Define separate objects for data transport between layers to decouple API contracts from domain models,Domain models annotated with serialization concerns | API field names leaking into business logic,API response mapping | GraphQL responses | Multi-source data aggregation | API versioning,DTO → Mapper → Domain Model,"// Domain model polluted with API concerns\n@Serializable\ndata class User(\n  @SerialName(""user_id"") val id: String,\n  @SerialName(""full_name"") val name: String,\n  @SerialName(""profile_image_url"") val avatar: String,\n  @Transient val isOnline: Boolean = false // mixed concerns\n)","// API layer\n@Serializable\ndata class UserDto(\n  @SerialName(""user_id"") val id: String,\n  @SerialName(""full_name"") val name: String,\n  @SerialName(""profile_image_url"") val avatarUrl: String\n)\n// Domain layer — clean\ndata class User(val id: String, val name: String, val avatar: String, val isOnline: Boolean)\n// Mapper\nfun UserDto.toDomain() = User(id = id, name = name, avatar = avatarUrl, isOnline = false)",Keep DTOs in data layer only. Domain models stay clean. Use extension functions for mapping. Room entities can be separate from DTOs and domain models.,https://developer.android.com/topic/architecture/data-layer
Data Transfer Object,Structural,iOS,dto data transfer object api response codable model layer separation swift,Define separate objects for data transport to decouple API from domain,Domain models annotated with Codable/CodingKeys | API field naming in business logic,API response mapping | Multi-API aggregation | API versioning | Backend migration,DTO → Mapper → Domain Model,"// Domain model polluted with API concerns\nstruct User: Codable {\n  let userId: String\n  let fullName: String\n  let profileImageUrl: String?\n  enum CodingKeys: String, CodingKey {\n    case userId = ""user_id""\n    case fullName = ""full_name""\n    case profileImageUrl = ""profile_image_url""\n  }\n}","// Data layer\nstruct UserDTO: Codable {\n  let userId: String\n  let fullName: String\n  let profileImageUrl: String?\n  enum CodingKeys: String, CodingKey {\n    case userId = ""user_id""; case fullName = ""full_name""; case profileImageUrl = ""profile_image_url""\n  }\n}\n// Domain layer\nstruct User { let id: String; let name: String; let avatar: URL? }\n// Mapper\nextension UserDTO {\n  var asDomain: User { User(id: userId, name: fullName, avatar: URL(string: profileImageUrl ?? """")) }\n}",DTOs absorb API changes so domain stays stable. Use Codable only on DTOs. Domain models use Swift types (URL not String). Extensions for clean mapping.,https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types
Data Transfer Object,Structural,Flutter,dto data transfer object api response json model layer separation dart,Define separate objects for data transport to decouple API from domain,Domain models mixed with fromJson/toJson | json_serializable annotations on business models,API response mapping | Firebase document mapping | GraphQL responses,DTO → Mapper → Domain Model,"// Domain model polluted with serialization\n@JsonSerializable()\nclass User {\n  @JsonKey(name: 'user_id') final String id;\n  @JsonKey(name: 'full_name') final String name;\n  @JsonKey(name: 'profile_image_url') final String? avatar;\n  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);\n}","// Data layer\n@JsonSerializable(fieldRename: FieldRename.snake)\nclass UserDto {\n  final String userId;\n  final String fullName;\n  final String? profileImageUrl;\n  factory UserDto.fromJson(Map<String, dynamic> json) => _$UserDtoFromJson(json);\n}\n// Domain layer\nclass User { final String id; final String name; final String? avatar; }\n// Mapper\nextension UserDtoMapper on UserDto {\n  User toDomain() => User(id: userId, name: fullName, avatar: profileImageUrl);\n}",Use json_serializable only on DTOs. Domain models stay clean Dart classes. Use freezed for domain models with equality and copyWith. Mappers as extensions.,https://pub.dev/packages/json_serializable
CQRS,Architectural,Android,cqrs command query separation read write responsibility segregation,Separate read and write operations into distinct models for independent optimization,Single repository handling both complex reads and writes | Read models shaped for writes not UI,Screens needing different data shapes for display vs mutation | Offline-first with sync | Event sourcing,Command → CommandHandler → WriteModel | Query → QueryHandler → ReadModel,"interface UserRepository {\n  suspend fun getUser(id: String): User // shaped for writes\n  suspend fun getUserWithPosts(id: String): UserWithPosts // shaped for UI\n  suspend fun getUserForEdit(id: String): EditableUser // shaped for forms\n  suspend fun updateUser(user: User) // write\n  // One interface tries to serve all shapes\n}","// Read side\nclass GetProfileQuery @Inject constructor(private val dao: UserDao) {\n  fun execute(id: String): Flow<ProfileView> = dao.getProfileView(id) // UI-optimized\n}\n// Write side\nclass UpdateProfileCommand @Inject constructor(private val repo: UserRepository) {\n  suspend fun execute(update: ProfileUpdate) { repo.update(update) }\n}\n// ViewModel uses both:\n// val profile = getProfileQuery.execute(id)\n// fun save() = updateProfileCommand.execute(update)",Full CQRS is rare in mobile. Use lightweight CQRS: read queries return Flow from Room (denormalized views) and write commands go through repositories.,https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs
Mutable State Exposure Refactor,Refactoring,Android,mutable state exposure encapsulation backing property private mutablestateflow,Hide mutable state behind read-only interfaces to prevent external mutation,MutableStateFlow/MutableLiveData exposed publicly | External code directly modifying ViewModel state,Any ViewModel with StateFlow | Repository exposing mutable collections | State holders,MutableStateFlow (private) → StateFlow (public),"class ProfileViewModel : ViewModel() {\n  val user = MutableStateFlow<User?>(null) // anyone can set this\n  val items = MutableStateFlow(mutableListOf<Item>()) // external mutation possible\n}\n// In Fragment: viewModel.user.value = hackedUser // oops","class ProfileViewModel : ViewModel() {\n  private val _user = MutableStateFlow<User?>(null)\n  val user: StateFlow<User?> = _user.asStateFlow()\n  private val _items = MutableStateFlow<List<Item>>(emptyList())\n  val items: StateFlow<List<Item>> = _items.asStateFlow()\n  fun updateUser(user: User) { _user.value = user } // controlled mutation\n}",Always use backing property pattern: private _mutable + public read-only. Use asStateFlow() not just type cast. Use immutable List not MutableList in state.,https://developer.android.com/kotlin/flow/stateflow-and-sharedflow
Mutable State Exposure Refactor,Refactoring,iOS,mutable state exposure encapsulation private published setter swift,Hide mutable state behind read-only interfaces to prevent external mutation,@Published properties settable from outside the ViewModel | Public vars on ObservableObject,Any ViewModel with @Published | Services exposing mutable state,Private(set) @Published → Read-only from outside,"class ProfileViewModel: ObservableObject {\n  @Published var user: User? // anyone can set from outside\n  @Published var items: [Item] = [] // external mutation\n}\n// In View: viewModel.user = hackedUser // oops","class ProfileViewModel: ObservableObject {\n  @Published private(set) var user: User?\n  @Published private(set) var items: [Item] = []\n  func updateUser(_ user: User) { self.user = user } // controlled\n}",Use private(set) on @Published to prevent external writes. Alternatively use CurrentValueSubject with eraseToAnyPublisher() for Combine-based encapsulation.,https://developer.apple.com/documentation/combine/published
Mutable State Exposure Refactor,Refactoring,Flutter,mutable state exposure encapsulation private stream controller dart,Hide mutable state behind read-only interfaces to prevent external mutation,Public StreamController or ValueNotifier directly accessible | State objects with public setters,BLoC/Cubit state management | Service classes | Repository caching,Private StreamController → Public Stream,"class UserService {\n  final controller = StreamController<User>.broadcast(); // anyone can add events\n  final users = <User>[]; // public mutable list\n}\n// Anywhere: service.controller.add(hackedUser); service.users.clear();","class UserService {\n  final _controller = StreamController<User>.broadcast();\n  Stream<User> get userStream => _controller.stream; // read-only\n  List<User> get users => List.unmodifiable(_users);\n  final _users = <User>[];\n  void updateUser(User user) { _users.add(user); _controller.add(user); }\n  void dispose() => _controller.close();\n}",Use private underscore convention in Dart. Expose Stream not StreamController. Return unmodifiable lists. BLoC pattern naturally encapsulates state.,https://dart.dev/effective-dart/design
Anemic Domain Model Refactor,Refactoring,All,anemic domain model behavior data class logic separation rich,Move business logic into domain models instead of keeping them as data-only containers,Domain models with only getters/data | All logic in service/use case classes operating on dumb data,Order total calculation | User eligibility | Shopping cart rules | Entity validation,Anemic model + external logic → Rich domain model,"// Anemic model — just data\ndata class Order(\n  val items: List<OrderItem>,\n  val coupon: Coupon?,\n  val taxRate: Double\n)\n// Logic elsewhere\nclass OrderService {\n  fun calculateTotal(order: Order): Double {\n    val subtotal = order.items.sumOf { it.price * it.quantity }\n    val discount = order.coupon?.let { subtotal * it.percent / 100 } ?: 0.0\n    return (subtotal - discount) * (1 + order.taxRate)\n  }\n  fun canCancel(order: Order): Boolean = order.items.all { !it.isShipped }\n}","data class Order(\n  val items: List<OrderItem>,\n  val coupon: Coupon?,\n  val taxRate: Double\n) {\n  val subtotal: Double get() = items.sumOf { it.price * it.quantity }\n  val discount: Double get() = coupon?.let { subtotal * it.percent / 100 } ?: 0.0\n  val total: Double get() = (subtotal - discount) * (1 + taxRate)\n  val canCancel: Boolean get() = items.all { !it.isShipped }\n}",Balance is key: simple computed properties belong in the model. Complex orchestration (calling repos/APIs) stays in UseCases. Not every model needs to be rich.,https://martinfowler.com/bliki/AnemicDomainModel.html
Train Wreck Refactor,Refactoring,All,train wreck law demeter chained calls coupling deep access,Reduce long chains of method calls that violate the Law of Demeter creating tight coupling,Long dot-chains accessing deeply nested objects | Methods reaching through multiple layers of objects,Accessing nested config | Navigating deep object graphs | Chained getter calls,Deep chain → Direct method / delegation,"// Train wreck — tightly coupled to entire object graph\nval city = order.customer.address.city\nval zipCode = order.customer.address.zipCode\nval discount = order.customer.membership.tier.discountPercent\nval taxRate = order.customer.address.state.taxRate","// Option 1: Delegate to intermediate objects\nclass Order {\n  val customerCity: String get() = customer.city\n  val discountPercent: Double get() = customer.discountPercent\n}\nclass Customer {\n  val city: String get() = address.city\n  val discountPercent: Double get() = membership.discountPercent\n}\n// Option 2: Pass what you need directly\nfun calculateTax(taxRate: Double, subtotal: Double): Double",Not all chained calls are train wrecks. Fluent APIs (builder.a().b().c()) and data access (dto.nested.field) are fine. Violates when calling behavior through chains.,https://refactoring.guru/refactoring/smells/message-chains
Data Clumps Refactor,Refactoring,All,data clumps group related fields parameter object extract class,Extract groups of fields that always appear together into their own class,Same 3+ fields repeated across multiple classes or method signatures | Parameters that always travel together,Address fields | Coordinate pairs | Date ranges | Money (amount + currency) | Dimensions (width + height),Repeated fields → Extracted class,"// Same fields repeated everywhere\nfun createOrder(street: String, city: String, state: String, zip: String, country: String) { ... }\nfun updateShipping(street: String, city: String, state: String, zip: String, country: String) { ... }\nfun validateAddress(street: String, city: String, state: String, zip: String, country: String): Boolean { ... }\ndata class User(val name: String, val street: String, val city: String, val state: String, val zip: String)","data class Address(\n  val street: String,\n  val city: String,\n  val state: String,\n  val zip: String,\n  val country: String\n) {\n  fun validate(): Boolean = street.isNotBlank() && zip.matches(Regex(""\\d{5}""))\n}\nfun createOrder(address: Address) { ... }\nfun updateShipping(address: Address) { ... }\ndata class User(val name: String, val address: Address)",If 3+ fields always appear together extract them. The new class often attracts behavior (validation). Use Kotlin value classes for lightweight wrappers.,https://refactoring.guru/refactoring/smells/data-clumps
Switch Statement Smell Refactor,Refactoring,All,switch statement smell polymorphism replace conditional sealed type,Replace type-checking switch/when statements with polymorphism,when/switch on type or enum that appears in multiple places | Adding a type requires changes in many switch blocks,Payment processing by type | Notification handling by type | Shape calculations | Permission checks by role,Switch on type → Polymorphic dispatch,"// Same switch appears in 5 places\nfun calculateFee(payment: Payment): Double {\n  return when (payment.type) {\n    ""credit_card"" -> payment.amount * 0.029\n    ""debit"" -> payment.amount * 0.015\n    ""paypal"" -> payment.amount * 0.035\n    ""crypto"" -> payment.amount * 0.01\n    else -> 0.0\n  }\n}\nfun processPayment(payment: Payment) {\n  when (payment.type) { /* same switch again */ }\n}","sealed class Payment(val amount: Double) {\n  class CreditCard(amount: Double) : Payment(amount) {\n    fun fee(): Double = amount * 0.029\n    fun process() { /* credit card logic */ }\n  }\n  class PayPal(amount: Double) : Payment(amount) {\n    fun fee(): Double = amount * 0.035\n    fun process() { /* paypal logic */ }\n  }\n}\n// Usage: payment.fee() — no switch needed. Adding new type = new class only.",One when/switch is often fine (in a factory). The smell is when the SAME switch appears in multiple places. Use sealed classes so the compiler enforces exhaustiveness.,https://refactoring.guru/refactoring/smells/switch-statements
Inappropriate Intimacy Refactor,Refactoring,All,inappropriate intimacy coupling internal access encapsulation friend,Reduce excessive coupling where classes access each other's internal details,Classes directly accessing private/internal fields of other classes | Circular dependencies between classes,Fragment accessing Activity internals | ViewModel reaching into View | Bidirectional dependencies,Tightly coupled classes → Interface/mediator,"class OrderViewModel {\n  lateinit var fragment: OrderFragment // holds reference to view!\n  fun onOrderPlaced() {\n    fragment.recyclerView.adapter?.notifyDataSetChanged() // reaching into view internals\n    fragment.loadingBar.visibility = View.GONE\n    fragment.toolbar.title = ""Order Placed""\n  }\n}","class OrderViewModel : ViewModel() {\n  private val _state = MutableStateFlow<OrderState>(OrderState.Loading)\n  val state: StateFlow<OrderState> = _state.asStateFlow()\n  fun onOrderPlaced() { _state.value = OrderState.Success(""Order Placed"") }\n}\n// Fragment observes state reactively — no direct coupling\n// viewModel.state.collect { state -> when(state) { ... } }",ViewModel should never reference Views/Fragments. Use reactive state (StateFlow/LiveData) as the communication boundary. In iOS use Combine @Published. In Flutter use BLoC.,https://refactoring.guru/refactoring/smells/inappropriate-intimacy
Middle Man Refactor,Refactoring,All,middle man delegation unnecessary wrapper passthrough remove,Remove classes that only delegate to another class without adding value,Classes where every method just calls the same method on a delegate | Unnecessary wrapper layers,Pass-through repository layers | Wrapper classes that add nothing | Unnecessary Use Cases for simple CRUD,MiddleMan → Direct access to delegate,"// UseCase that adds zero value\nclass GetUserUseCase @Inject constructor(\n  private val repo: UserRepository\n) {\n  suspend operator fun invoke(id: String): User {\n    return repo.getUser(id) // just passes through!\n  }\n}\nclass GetProductsUseCase @Inject constructor(\n  private val repo: ProductRepository\n) {\n  suspend operator fun invoke(): List<Product> {\n    return repo.getProducts() // just passes through!\n  }\n}","// Skip the UseCase for simple pass-through\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n  private val userRepo: UserRepository, // inject repo directly\n  private val placeOrder: PlaceOrderUseCase // keep UseCase only when it has logic\n) : ViewModel() {\n  fun loadUser(id: String) = userRepo.getUser(id)\n}",Not every operation needs a UseCase. Only create UseCases when they contain business logic or coordinate multiple repos. YAGNI applies to architecture layers.,https://refactoring.guru/refactoring/smells/middle-man
Duplicate Code Refactor,Refactoring,All,duplicate code extract method template strategy copy paste DRY,Extract duplicated code into shared methods or apply patterns to eliminate copy-paste,Same code block appearing in 2+ places | Similar methods with minor variations | Copy-pasted logic across classes,Validation logic duplicated | Formatting repeated | API call patterns duplicated | Error handling copy-pasted,Duplicated code → Extracted method/Template Method/Strategy,"class OrderScreen {\n  fun showError(message: String) {\n    snackbar.setText(message)\n    snackbar.setBackgroundColor(Color.RED)\n    snackbar.setDuration(3000)\n    snackbar.show()\n    analytics.trackError(message)\n  }\n}\nclass ProfileScreen {\n  fun showError(message: String) {\n    snackbar.setText(message)\n    snackbar.setBackgroundColor(Color.RED)\n    snackbar.setDuration(3000)\n    snackbar.show()\n    analytics.trackError(message)\n  } // exact copy!\n}","// Extract into shared utility\nclass ErrorHandler @Inject constructor(\n  private val analytics: Analytics\n) {\n  fun show(view: View, message: String) {\n    Snackbar.make(view, message, 3000)\n      .setBackgroundTint(Color.RED)\n      .show()\n    analytics.trackError(message)\n  }\n}\n// Or in Compose: shared composable\n@Composable\nfun ErrorSnackbar(message: String) { ... }",Rule of Three: extract when duplicated in 3+ places. For similar-but-not-identical code use Template Method or Strategy instead of forced extraction.,https://refactoring.guru/refactoring/smells/duplicate-code
Magic Numbers Refactor,Refactoring,All,magic numbers strings constants enum named meaningful replace,Replace unexplained literal values with named constants or enums,Hard-coded numbers or strings without explanation | Same literal value used in multiple places,Timeout values | API endpoints | Status codes | Dimension values | Error messages,Magic literals → Named constants/enums,"fun fetchData() {\n  val client = OkHttpClient.Builder()\n    .connectTimeout(30, TimeUnit.SECONDS) // why 30?\n    .readTimeout(60, TimeUnit.SECONDS) // why 60?\n    .build()\n  if (response.code == 429) { delay(5000) } // what is 429? what is 5000?\n  if (items.size > 50) { paginate() } // why 50?\n}","object NetworkConfig {\n  const val CONNECT_TIMEOUT_SECONDS = 30L\n  const val READ_TIMEOUT_SECONDS = 60L\n  const val RATE_LIMIT_CODE = 429\n  const val RATE_LIMIT_DELAY_MS = 5000L\n}\nconst val MAX_ITEMS_PER_PAGE = 50\n\nfun fetchData() {\n  val client = OkHttpClient.Builder()\n    .connectTimeout(NetworkConfig.CONNECT_TIMEOUT_SECONDS, TimeUnit.SECONDS)\n    .readTimeout(NetworkConfig.READ_TIMEOUT_SECONDS, TimeUnit.SECONDS)\n    .build()\n  if (response.code == NetworkConfig.RATE_LIMIT_CODE) { delay(NetworkConfig.RATE_LIMIT_DELAY_MS) }\n}",Use const val in Kotlin / static let in Swift / static const in Dart for compile-time constants. Group related constants in objects. Use enums for finite sets.,https://refactoring.guru/refactoring/smells/magic-numbers
Temporal Coupling Refactor,Refactoring,All,temporal coupling initialization order method sequence hidden dependency,Eliminate hidden dependencies on method call order that cause runtime errors,Methods that must be called in a specific order but nothing enforces it | Init methods that crash if called out of order,SDK initialization | Multi-step setup | Builder without enforcement | Two-phase initialization,Temporal coupling → Builder/Constructor enforcement,"class AnalyticsTracker {\n  private lateinit var apiKey: String\n  private lateinit var userId: String\n  fun setApiKey(key: String) { apiKey = key }\n  fun setUserId(id: String) { userId = id }\n  fun init() { /* crashes if setApiKey not called first */ }\n  fun track(event: String) { /* crashes if init not called */ }\n}\n// Must call: setApiKey → setUserId → init → track (but nothing enforces this!)","class AnalyticsTracker private constructor(\n  private val apiKey: String,\n  private val userId: String\n) {\n  fun track(event: String) { /* safe — always fully initialized */ }\n  class Builder {\n    private var apiKey: String? = null\n    private var userId: String? = null\n    fun apiKey(key: String) = apply { apiKey = key }\n    fun userId(id: String) = apply { userId = id }\n    fun build(): AnalyticsTracker {\n      requireNotNull(apiKey) { ""apiKey is required"" }\n      requireNotNull(userId) { ""userId is required"" }\n      return AnalyticsTracker(apiKey!!, userId!!)\n    }\n  }\n}",Use constructors/builders to enforce required fields. Use state machines (sealed classes) to enforce valid transitions. Make illegal states unrepresentable.,https://blog.ploeh.dk/2011/05/24/DesignSmellTemporalCoupling/
Dead Code Refactor,Refactoring,All,dead code unused unreachable remove cleanup deprecated,Remove code that is never executed or referenced to reduce maintenance burden,Methods never called | Conditions that can never be true | Commented-out code blocks | Unused imports and variables,Deprecated features | Abandoned experiments | Removed feature flags | Old API compatibility code,Dead code → Delete,"class UserRepository {\n  fun getUser(id: String): User { ... } // used\n  fun getUserV1(id: String): User { ... } // old version — never called\n  fun getUserByEmail(email: String): User { ... } // was used in removed feature\n  // fun getBlockedUsers(): List<User> { ... } // commented out ""just in case""\n  @Deprecated(""Use getUser"")\n  fun fetchUser(id: String): User { return getUser(id) } // no callers\n}","class UserRepository {\n  fun getUser(id: String): User { ... } // only what's used\n}\n// Deleted: getUserV1, getUserByEmail, commented block, fetchUser\n// Git history preserves old code if ever needed",Delete fearlessly — git has your back. Use IDE analysis (Android Studio: Analyze → Run Inspection) to find unused declarations. Commented-out code is dead code.,https://refactoring.guru/refactoring/smells/dead-code
Extension Functions Pattern,Structural,Android,extension function utility helper scope readable kotlin idiomatic,Add behavior to existing classes without inheritance using extension functions,Utility classes with static methods taking the object as first parameter | Helper classes wrapping simple operations,String formatting | View helpers | Context extensions | Collection utilities | Domain model extensions,UtilityClass.method(obj) → obj.method(),"object StringUtils {\n  fun capitalize(s: String): String = s.replaceFirstChar { it.uppercase() }\n  fun isValidEmail(s: String): Boolean = s.matches(Regex("".*@.*\\..*""))\n  fun truncate(s: String, maxLen: Int): String = if (s.length > maxLen) s.take(maxLen) + ""..."" else s\n}\n// Usage: StringUtils.capitalize(name) // Java-style utility","fun String.capitalizeFirst(): String = replaceFirstChar { it.uppercase() }\nfun String.isValidEmail(): Boolean = matches(Regex("".*@.*\\..*""))\nfun String.truncate(maxLen: Int): String = if (length > maxLen) take(maxLen) + ""..."" else this\n// Usage: name.capitalizeFirst() // idiomatic Kotlin",Extensions add discoverability via autocomplete. Use for stateless utilities. Don't overuse — if it needs state use a class. Place in dedicated .extensions package.,https://kotlinlang.org/docs/extensions.html
Extension Functions Pattern,Structural,iOS,extension protocol extension utility helper readable swift idiomatic,Add behavior to existing types without inheritance using extensions,Utility classes with static methods | Helper functions taking the object as first parameter,String formatting | UIView helpers | Date extensions | Collection utilities,UtilityClass.method(obj) → obj.method(),"class StringUtils {\n  static func capitalize(_ s: String) -> String { s.prefix(1).uppercased() + s.dropFirst() }\n  static func isValidEmail(_ s: String) -> Bool { s.contains(""@"") && s.contains(""."") }\n  static func truncate(_ s: String, maxLen: Int) -> String { s.count > maxLen ? String(s.prefix(maxLen)) + ""..."" : s }\n}\n// Usage: StringUtils.capitalize(name)","extension String {\n  var capitalizedFirst: String { prefix(1).uppercased() + dropFirst() }\n  var isValidEmail: Bool { contains(""@"") && contains(""."") }\n  func truncated(maxLen: Int) -> String { count > maxLen ? String(prefix(maxLen)) + ""..."" : self }\n}\n// Usage: name.capitalizedFirst // idiomatic Swift",Swift extensions + protocol extensions are powerful. Use protocol extensions for default implementations. Computed properties for derived values. Keep extensions focused.,https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/
Extension Functions Pattern,Structural,Flutter,extension method utility helper readable dart idiomatic,Add behavior to existing types without inheritance using extension methods,Utility classes with static methods | Helper functions scattered in utils files,String formatting | Widget helpers | BuildContext extensions | DateTime utilities,UtilityClass.method(obj) → obj.method(),"class StringUtils {\n  static String capitalize(String s) => '${s[0].toUpperCase()}${s.substring(1)}';\n  static bool isValidEmail(String s) => s.contains('@') && s.contains('.');\n  static String truncate(String s, int maxLen) => s.length > maxLen ? '${s.substring(0, maxLen)}...' : s;\n}\n// Usage: StringUtils.capitalize(name)","extension StringExtensions on String {\n  String get capitalizedFirst => '${this[0].toUpperCase()}${substring(1)}';\n  bool get isValidEmail => contains('@') && contains('.');\n  String truncate(int maxLen) => length > maxLen ? '${substring(0, maxLen)}...' : this;\n}\n// Usage: name.capitalizedFirst // idiomatic Dart",Dart extensions add discoverability via autocomplete. Use for stateless utilities. BuildContext extensions are powerful for theming/navigation helpers.,https://dart.dev/language/extension-methods
Flyweight,Structural,iOS,flyweight memory sharing cache pool object reuse swift intrinsic,Share common state among many objects to reduce memory consumption,Many similar objects storing duplicate immutable data | High memory from repeated AttributedString/UIFont creation,Shared UIFont/NSAttributedString | Cell configuration caching | Map annotation reuse | Particle effects,FlyweightFactory → Flyweight,"// Each cell creates its own attributed string config\nfunc configure(cell: UITableViewCell, item: Item) {\n  let font = UIFont.systemFont(ofSize: 16, weight: .bold) // created per cell\n  let color = UIColor(named: ""primary"")! // looked up per cell\n  cell.textLabel?.font = font\n  cell.textLabel?.textColor = color\n}","enum AppFonts {\n  static let bodyBold = UIFont.systemFont(ofSize: 16, weight: .bold)\n  static let caption = UIFont.systemFont(ofSize: 12, weight: .regular)\n}\nenum AppColors {\n  static let primary = UIColor(named: ""primary"")!\n}\nfunc configure(cell: UITableViewCell, item: Item) {\n  cell.textLabel?.font = AppFonts.bodyBold // shared instance\n  cell.textLabel?.textColor = AppColors.primary\n}",UIFont and UIColor are already cached by the system to some degree. Use static let for app-wide shared instances. SwiftUI caches Text styles automatically.,https://refactoring.guru/design-patterns/flyweight
Observer,Behavioral,React Native,observer event listener callback reactive state notification hooks,Define a subscription mechanism to notify multiple objects about events,Manual event listeners with addEventListener/removeEventListener boilerplate | Prop drilling for state changes,Global state subscriptions | Event emitters across native modules | Real-time data streams,Subject → Observer,"const DataContext = React.createContext(null);\n// Prop drilling through 5 levels\n<App data={data} onUpdate={setData}>\n  <Screen data={data} onUpdate={setData}>\n    <Section data={data} onUpdate={setData}>\n      <Component data={data} />","// Using Zustand or similar\nconst useStore = create((set) => ({\n  data: null,\n  setData: (data) => set({ data }),\n}));\n// Any component:\nconst data = useStore((s) => s.data);\n// Updates automatically when data changes",React hooks (useState/useContext/useSyncExternalStore) are built-in observers. Use Zustand/Jotai for global state. Avoid EventEmitter patterns in JS — use reactive state.,https://docs.pmnd.rs/zustand
Strategy,Behavioral,Android,strategy algorithm interchangeable behavior policy kotlin lambda,Define a family of algorithms and make them interchangeable using Kotlin lambdas,Long when/if-else selecting algorithms | Duplicated conditional logic across multiple call sites,Sort/filter algorithms | Image compression strategies | Retry policies | Caching strategies,Context → (T) -> R lambda,"fun compress(image: Bitmap, quality: String): ByteArray {\n  return when (quality) {\n    ""high"" -> compressJpeg(image, 95)\n    ""medium"" -> compressJpeg(image, 75)\n    ""low"" -> compressWebp(image, 60)\n    ""thumbnail"" -> compressWebp(resize(image, 200), 50)\n    else -> compressJpeg(image, 80)\n  } // switch grows with each new strategy\n}","fun interface CompressStrategy {\n  fun compress(image: Bitmap): ByteArray\n}\nval highQuality = CompressStrategy { compressJpeg(it, 95) }\nval thumbnail = CompressStrategy { compressWebp(resize(it, 200), 50) }\nclass ImageProcessor(private val strategy: CompressStrategy) {\n  fun process(image: Bitmap): ByteArray = strategy.compress(image)\n}",Kotlin fun interface + lambda makes Strategy zero-overhead. Inject strategies via Hilt. Swap at runtime for A/B tests. Each strategy is independently testable.,https://refactoring.guru/design-patterns/strategy
Strategy,Behavioral,iOS,strategy algorithm interchangeable behavior policy swift closure protocol,Define a family of algorithms and make them interchangeable using protocols or closures,Long switch statements selecting algorithms | Duplicated conditional chains,Sort/filter algorithms | Authentication methods | Image processing | Retry policies,Context → Protocol/Closure,"func compress(_ image: UIImage, quality: String) -> Data {\n  switch quality {\n  case ""high"": return image.jpegData(compressionQuality: 0.95)!\n  case ""medium"": return image.jpegData(compressionQuality: 0.75)!\n  case ""low"": return image.pngData()!\n  default: return image.jpegData(compressionQuality: 0.8)!\n  }\n}","protocol CompressStrategy {\n  func compress(_ image: UIImage) -> Data\n}\nstruct HighQualityJPEG: CompressStrategy {\n  func compress(_ image: UIImage) -> Data { image.jpegData(compressionQuality: 0.95)! }\n}\nstruct Thumbnail: CompressStrategy {\n  func compress(_ image: UIImage) -> Data { image.resized(to: 200).jpegData(compressionQuality: 0.5)! }\n}\n// Or use closures: typealias CompressStrategy = (UIImage) -> Data",Swift closures are lightweight strategies. Use protocols when strategies have state or multiple methods. Inject via init for testability.,https://refactoring.guru/design-patterns/strategy
Strategy,Behavioral,Flutter,strategy algorithm interchangeable behavior policy dart typedef,Define a family of algorithms and make them interchangeable using typedef or abstract classes,Long switch/if-else selecting algorithms | Duplicated conditional logic,Sort/filter algorithms | Validation strategies | Image processing | Theming,Context → Function typedef or abstract class,"Widget buildChart(String type, List<double> data) {\n  switch (type) {\n    case 'bar': return BarChart(data: data);\n    case 'line': return LineChart(data: data);\n    case 'pie': return PieChart(data: data);\n    default: return BarChart(data: data);\n  }\n}","typedef ChartBuilder = Widget Function(List<double> data);\nfinal barChart = (List<double> data) => BarChart(data: data);\nfinal lineChart = (List<double> data) => LineChart(data: data);\nfinal pieChart = (List<double> data) => PieChart(data: data);\nclass ChartWidget extends StatelessWidget {\n  final ChartBuilder builder;\n  final List<double> data;\n  const ChartWidget({required this.builder, required this.data});\n  @override\n  Widget build(BuildContext context) => builder(data);\n}",Dart typedef + first-class functions make Strategy lightweight. Use abstract class when strategy needs state. Inject via constructor for testability.,https://refactoring.guru/design-patterns/strategy
State,Behavioral,Android,state machine transition behavior change sealed kotlin compose,Allow an object to alter its behavior when its internal state changes using Kotlin sealed classes,Complex if/else chains checking currentState | Boolean flags controlling different behaviors | when blocks repeated across methods,Media player states | Download manager | Authentication flow | Checkout steps | Connection status,Sealed class → State transitions,"class DownloadManager {\n  var isDownloading = false\n  var isPaused = false\n  var isCompleted = false\n  var error: String? = null\n  fun onTap() {\n    if (isDownloading && !isPaused) { isPaused = true }\n    else if (isPaused) { isPaused = false; isDownloading = true }\n    else if (isCompleted) { /* open file */ }\n    else if (error != null) { error = null; isDownloading = true }\n    else { isDownloading = true }\n  } // impossible states possible!\n}","sealed class DownloadState {\n  object Idle : DownloadState() { fun start() = Downloading(0) }\n  data class Downloading(val progress: Int) : DownloadState() { fun pause() = Paused(progress); fun complete() = Completed }\n  data class Paused(val progress: Int) : DownloadState() { fun resume() = Downloading(progress) }\n  object Completed : DownloadState() { fun open() { /* open file */ } }\n  data class Error(val message: String) : DownloadState() { fun retry() = Downloading(0) }\n}\n// Impossible states are now impossible!",Kotlin sealed classes prevent impossible states at compile time. Each state defines only its valid transitions. Combine with StateFlow for reactive UI updates.,https://developer.android.com/kotlin/flow/stateflow-and-sharedflow
State,Behavioral,iOS,state machine transition behavior change enum swift associated values,Allow an object to alter its behavior when its internal state changes using enums,Multiple booleans tracking state | Complex if/else checking state combinations | Invalid state possible,Media player | Download manager | Auth flow | Form validation | Network connectivity,Enum → State transitions,"class DownloadManager {\n  var isDownloading = false\n  var isPaused = false\n  var progress = 0.0\n  var error: Error?\n  func onTap() {\n    if isDownloading && !isPaused { isPaused = true }\n    else if isPaused { isPaused = false }\n    else { isDownloading = true }\n  } // bugs: can be downloading AND have error\n}","enum DownloadState {\n  case idle\n  case downloading(progress: Double)\n  case paused(progress: Double)\n  case completed(fileURL: URL)\n  case error(Error)\n  func onTap() -> DownloadState {\n    switch self {\n    case .idle: return .downloading(progress: 0)\n    case .downloading(let p): return .paused(progress: p)\n    case .paused(let p): return .downloading(progress: p)\n    case .completed: return .idle // re-download\n    case .error: return .downloading(progress: 0)\n    }\n  }\n}",Swift enums with associated values are perfect state machines. Each case carries only its relevant data. Use @Published for reactive state observation.,https://developer.apple.com/documentation/swift/enumerations
State,Behavioral,Flutter,state machine transition behavior change sealed dart bloc,Allow an object to alter its behavior when its internal state changes using sealed classes,Multiple boolean fields in state | Complex if/else in event handlers | Invalid state combinations possible,Media player | Download manager | Auth flow | Form steps | Connection status,Sealed class → State transitions,"class DownloadState {\n  bool isDownloading = false;\n  bool isPaused = false;\n  double progress = 0;\n  String? error;\n  // Can be downloading AND paused AND have error simultaneously!\n}","sealed class DownloadState {}\nclass DownloadIdle extends DownloadState {}\nclass Downloading extends DownloadState { final double progress; Downloading(this.progress); }\nclass DownloadPaused extends DownloadState { final double progress; DownloadPaused(this.progress); }\nclass DownloadComplete extends DownloadState { final String filePath; DownloadComplete(this.filePath); }\nclass DownloadError extends DownloadState { final String message; DownloadError(this.message); }\n// BLoC handles transitions: on<PauseTap>((e, emit) { if (state is Downloading) emit(DownloadPaused((state as Downloading).progress)); });",Dart 3 sealed classes + BLoC = perfect state machines. Each state carries only its data. Switch patterns enforce exhaustive handling. Use freezed for boilerplate reduction.,https://bloclibrary.dev/
Facade,Structural,Android,facade simplify subsystem interface complex sdk wrapper,Provide a simplified interface to a complex subsystem of Android SDK calls,Multiple Android SDK calls scattered across ViewModels | Complex multi-step SDK initialization repeated,Firebase wrapper | Media player management | Permission handling | Notification builder | Bluetooth management,Facade → Android SDK subsystems,"class ProfileViewModel : ViewModel() {\n  fun shareProfile(user: User) {\n    val intent = Intent(Intent.ACTION_SEND)\n    intent.type = ""text/plain""\n    intent.putExtra(Intent.EXTRA_SUBJECT, user.name)\n    intent.putExtra(Intent.EXTRA_TEXT, ""Check out ${user.name}'s profile: ${user.profileUrl}"")\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n    val chooser = Intent.createChooser(intent, ""Share via"")\n    context.startActivity(chooser) // repeated in 5 places\n  }\n}","class ShareFacade @Inject constructor(\n  @ApplicationContext private val context: Context\n) {\n  fun shareText(title: String, text: String) {\n    val intent = Intent(Intent.ACTION_SEND).apply {\n      type = ""text/plain""\n      putExtra(Intent.EXTRA_SUBJECT, title)\n      putExtra(Intent.EXTRA_TEXT, text)\n      addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n    }\n    context.startActivity(Intent.createChooser(intent, ""Share via""))\n  }\n}\n// Usage: shareFacade.shareText(user.name, ""Check out ${user.name}..."")","Common Android Facades: NotificationHelper (wraps NotificationManager + channels), PermissionHelper (wraps ActivityResultContracts), ShareHelper. Inject via Hilt.",https://refactoring.guru/design-patterns/facade
Facade,Structural,iOS,facade simplify subsystem interface complex sdk wrapper swift,Provide a simplified interface to a complex subsystem of iOS SDK calls,Multiple UIKit/Foundation calls scattered across ViewControllers | Complex SDK setup repeated,Share sheet wrapper | UserDefaults wrapper | Keychain access | HealthKit | StoreKit,Facade → iOS SDK subsystems,"class ProfileVC: UIViewController {\n  func shareProfile() {\n    let text = ""Check out \\(user.name)""\n    let url = URL(string: user.profileUrl)!\n    let items: [Any] = [text, url]\n    let vc = UIActivityViewController(activityItems: items, applicationActivities: nil)\n    vc.excludedActivityTypes = [.addToReadingList]\n    if let popover = vc.popoverPresentationController {\n      popover.sourceView = shareButton\n    }\n    present(vc, animated: true) // repeated in many VCs\n  }\n}","class ShareFacade {\n  static func share(text: String, url: URL?, from vc: UIViewController, sourceView: UIView? = nil) {\n    var items: [Any] = [text]\n    if let url { items.append(url) }\n    let activityVC = UIActivityViewController(activityItems: items, applicationActivities: nil)\n    activityVC.excludedActivityTypes = [.addToReadingList]\n    if let popover = activityVC.popoverPresentationController {\n      popover.sourceView = sourceView ?? vc.view\n    }\n    vc.present(activityVC, animated: true)\n  }\n}",Common iOS facades: KeychainWrapper, UserDefaultsManager, NotificationScheduler, LocationManager wrapper. SwiftUI .sheet() and .shareLink() simplify some facades.,https://refactoring.guru/design-patterns/facade
Facade,Structural,Flutter,facade simplify subsystem interface complex plugin wrapper dart,Provide a simplified interface to a complex subsystem of Flutter plugins,Multiple plugin calls scattered across widgets/blocs | Complex platform channel setup repeated,Share plugin wrapper | Permission handler | Local notification setup | In-app purchase,Facade → Plugin subsystems,"class ProfilePage extends StatelessWidget {\n  Future<void> shareProfile(User user) async {\n    final box = context.findRenderObject() as RenderBox?;\n    await Share.share(\n      'Check out ${user.name}: ${user.profileUrl}',\n      subject: user.name,\n      sharePositionOrigin: box != null ? box.localToGlobal(Offset.zero) & box.size : Rect.zero,\n    ); // repeated with slight variations\n  }\n}","class ShareFacade {\n  Future<void> shareText(String title, String text, {Rect? origin}) async {\n    await Share.share(text, subject: title, sharePositionOrigin: origin ?? Rect.zero);\n  }\n  Future<void> shareFile(String path, {String? text}) async {\n    await Share.shareXFiles([XFile(path)], text: text);\n  }\n}\n// Usage: shareFacade.shareText(user.name, 'Check out...');",Common Flutter facades: PermissionFacade (wraps permission_handler), NotificationFacade (wraps flutter_local_notifications), AnalyticsFacade. Register in get_it/riverpod.,https://refactoring.guru/design-patterns/facade
Decorator,Structural,Android,decorator wrapper extend behavior dynamically composition logging caching,Attach additional responsibilities to objects dynamically without modifying their code using Kotlin delegation,Subclass explosion to add variations | Cross-cutting concerns (logging/caching) duplicated in every implementation,Adding logging to repository | Caching layer | Adding authentication headers | Analytics wrapping | Retry logic,Component → Decorator (by delegation),"// Logging added directly to implementation — violates SRP\nclass UserRepositoryImpl @Inject constructor(\n  private val api: UserApi,\n  private val dao: UserDao\n) : UserRepository {\n  override suspend fun getUser(id: String): User {\n    Log.d(""UserRepo"", ""getUser called with id=$id"") // logging mixed in\n    val user = dao.getUser(id) ?: api.getUser(id).also { dao.insert(it) }\n    Log.d(""UserRepo"", ""getUser returned ${user.name}"") // logging mixed in\n    return user\n  }\n}","class LoggingUserRepository(\n  private val delegate: UserRepository\n) : UserRepository by delegate {\n  override suspend fun getUser(id: String): User {\n    Log.d(""UserRepo"", ""getUser($id)"")\n    return delegate.getUser(id).also { Log.d(""UserRepo"", ""returned ${it.name}"") }\n  }\n}\n// DI: bind LoggingUserRepository(CachingUserRepository(UserRepositoryImpl()))\n// Each decorator adds one concern. Compose via DI.",Kotlin by delegation makes Decorator concise. Chain decorators via DI. Each decorator wraps one concern (logging caching auth). Order matters in the chain.,https://refactoring.guru/design-patterns/decorator
Decorator,Structural,iOS,decorator wrapper extend behavior dynamically composition swift logging caching,Attach additional responsibilities to objects dynamically without modifying their code,Subclass explosion | Cross-cutting concerns duplicated across implementations | Logging/caching mixed with business logic,Adding logging | Caching | Auth header injection | Retry logic | Rate limiting,Protocol → Decorator → Wrapped implementation,"class UserRepositoryImpl: UserRepository {\n  func getUser(id: String) async throws -> User {\n    print(""getUser called"") // logging mixed in\n    let dto = try await api.getUser(id)\n    let user = dto.toDomain()\n    print(""getUser returned \\(user.name)"") // logging mixed in\n    return user\n  }\n}","class LoggingUserRepository: UserRepository {\n  private let wrapped: UserRepository\n  init(wrapping repo: UserRepository) { self.wrapped = repo }\n  func getUser(id: String) async throws -> User {\n    print(""getUser(\\(id))"")\n    let user = try await wrapped.getUser(id: id)\n    print(""returned \\(user.name)"")\n    return user\n  }\n}\n// Compose: LoggingUserRepository(wrapping: CachingUserRepository(wrapping: UserRepositoryImpl()))",Swift protocol conformance enables clean Decorator. No built-in delegation keyword — implement protocol methods manually. Chain decorators in DI container.,https://refactoring.guru/design-patterns/decorator
Decorator,Structural,Flutter,decorator wrapper extend behavior dynamically composition dart logging caching,Attach additional responsibilities to objects dynamically without modifying their code,Subclass explosion for feature variations | Cross-cutting concerns duplicated | Logging mixed with business logic,Adding logging | Caching | Error handling | Analytics wrapping | Retry logic,Abstract class → Decorator → Wrapped implementation,"class UserRepositoryImpl implements UserRepository {\n  @override\n  Future<User> getUser(String id) async {\n    print('getUser called'); // logging mixed in\n    final dto = await api.getUser(id);\n    print('getUser returned'); // logging mixed in\n    return dto.toDomain();\n  }\n}","class LoggingUserRepository implements UserRepository {\n  final UserRepository _wrapped;\n  LoggingUserRepository(this._wrapped);\n  @override\n  Future<User> getUser(String id) async {\n    print('getUser($id)');\n    final user = await _wrapped.getUser(id);\n    print('returned ${user.name}');\n    return user;\n  }\n}\n// Compose: LoggingUserRepository(CachingUserRepository(UserRepositoryImpl()))",Chain decorators via get_it/riverpod registration. Each decorator implements the same interface. Use for composable cross-cutting concerns.,https://refactoring.guru/design-patterns/decorator
