ID,Name,Platform,Category,Keywords,Description,Code,Imports,Notes,Reference URL
viewmodel_basic,Basic ViewModel,Android,Architecture,"viewmodel state flow hilt inject","Standard HiltViewModel with UiState sealed interface","@HiltViewModel\nclass HomeViewModel @Inject constructor(\n    private val repository: HomeRepository\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow<HomeUiState>(HomeUiState.Loading)\n    val uiState: StateFlow<HomeUiState> = _uiState.asStateFlow()\n\n    init { loadData() }\n\n    fun loadData() {\n        viewModelScope.launch {\n            _uiState.value = HomeUiState.Loading\n            try {\n                val data = repository.getData()\n                _uiState.value = HomeUiState.Success(data)\n            } catch (e: Exception) {\n                _uiState.value = HomeUiState.Error(e.message ?: \"Unknown error\")\n            }\n        }\n    }\n}\n\nsealed interface HomeUiState {\n    data object Loading : HomeUiState\n    data class Success(val items: List<Item>) : HomeUiState\n    data class Error(val message: String) : HomeUiState\n}","import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject","Always use sealed interface for UiState. Expose immutable StateFlow.",https://developer.android.com/topic/libraries/architecture/viewmodel
viewmodel_event,ViewModel with Events,Android,Architecture,"viewmodel event channel side effect navigation snackbar","ViewModel with one-shot events via Channel for navigation/snackbar","@HiltViewModel\nclass LoginViewModel @Inject constructor(\n    private val authRepository: AuthRepository\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(LoginUiState())\n    val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow()\n\n    private val _events = Channel<LoginEvent>(Channel.BUFFERED)\n    val events: Flow<LoginEvent> = _events.receiveAsFlow()\n\n    fun onLoginClick(email: String, password: String) {\n        viewModelScope.launch {\n            _uiState.update { it.copy(isLoading = true) }\n            val result = authRepository.login(email, password)\n            _uiState.update { it.copy(isLoading = false) }\n            result.fold(\n                onSuccess = { _events.send(LoginEvent.NavigateToHome) },\n                onFailure = { _events.send(LoginEvent.ShowError(it.message ?: \"Login failed\")) }\n            )\n        }\n    }\n}\n\ndata class LoginUiState(\n    val isLoading: Boolean = false\n)\n\nsealed interface LoginEvent {\n    data object NavigateToHome : LoginEvent\n    data class ShowError(val message: String) : LoginEvent\n}","import kotlinx.coroutines.channels.Channel\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.receiveAsFlow\nimport kotlinx.coroutines.flow.update","Use Channel for one-shot events. Never use SharedFlow(replay=0) for events.",https://developer.android.com/topic/architecture/ui-layer/events
repository_basic,Repository Pattern,Android,Architecture,"repository datasource local remote offline cache","Repository with local cache and remote fallback","class ItemRepository @Inject constructor(\n    private val api: ItemApi,\n    private val dao: ItemDao,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) {\n    fun getItems(): Flow<List<Item>> = dao.observeAll()\n        .map { entities -> entities.map { it.toDomain() } }\n\n    suspend fun refreshItems() = withContext(ioDispatcher) {\n        val remote = api.getItems()\n        dao.upsertAll(remote.map { it.toEntity() })\n    }\n\n    suspend fun getItem(id: String): Item = withContext(ioDispatcher) {\n        dao.getById(id)?.toDomain()\n            ?: api.getItem(id).toDomain().also { dao.upsert(it.toEntity()) }\n    }\n}","import kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map\nimport kotlinx.coroutines.withContext\nimport javax.inject.Inject","Room as single source of truth. Expose Flow from DAO for reactive UI.",https://developer.android.com/topic/architecture/data-layer
repository_result,Repository with Result,Android,Architecture,"repository result wrapper error handling sealed","Repository returning Result wrapper for explicit error handling","class UserRepository @Inject constructor(\n    private val api: UserApi,\n    private val dao: UserDao\n) {\n    suspend fun getUser(id: String): Result<User> = runCatching {\n        val cached = dao.getById(id)\n        if (cached != null && !cached.isStale()) {\n            return Result.success(cached.toDomain())\n        }\n        val remote = api.getUser(id)\n        dao.upsert(remote.toEntity())\n        remote.toDomain()\n    }\n\n    suspend fun updateProfile(user: User): Result<Unit> = runCatching {\n        api.updateUser(user.toDto())\n        dao.upsert(user.toEntity())\n    }\n}","import javax.inject.Inject","Use runCatching for clean error propagation to ViewModel.",https://developer.android.com/topic/architecture/data-layer
hilt_module,Hilt DI Module,Android,DI,"hilt module provides singleton binds","Standard Hilt module with @Provides and @Binds","@Module\n@InstallIn(SingletonComponent::class)\nabstract class RepositoryModule {\n    @Binds\n    abstract fun bindUserRepository(\n        impl: UserRepositoryImpl\n    ): UserRepository\n}\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    @Provides\n    @Singleton\n    fun provideOkHttpClient(): OkHttpClient = OkHttpClient.Builder()\n        .addInterceptor(HttpLoggingInterceptor().apply {\n            level = if (BuildConfig.DEBUG) BODY else NONE\n        })\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .build()\n\n    @Provides\n    @Singleton\n    fun provideRetrofit(client: OkHttpClient): Retrofit = Retrofit.Builder()\n        .baseUrl(BuildConfig.BASE_URL)\n        .client(client)\n        .addConverterFactory(MoshiConverterFactory.create())\n        .build()\n\n    @Provides\n    @Singleton\n    fun provideUserApi(retrofit: Retrofit): UserApi =\n        retrofit.create(UserApi::class.java)\n}","import dagger.Binds\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton","Use @Binds for interface-impl bindings. @Provides for 3rd-party objects.",https://developer.android.com/training/dependency-injection/hilt-android
hilt_qualifiers,Hilt Dispatchers,Android,DI,"hilt qualifier dispatcher io default main coroutine","Hilt qualifier annotations for Coroutine Dispatchers","@Qualifier\n@Retention(AnnotationRetention.BINARY)\nannotation class IoDispatcher\n\n@Qualifier\n@Retention(AnnotationRetention.BINARY)\nannotation class DefaultDispatcher\n\n@Qualifier\n@Retention(AnnotationRetention.BINARY)\nannotation class MainDispatcher\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DispatcherModule {\n    @IoDispatcher\n    @Provides\n    fun provideIoDispatcher(): CoroutineDispatcher = Dispatchers.IO\n\n    @DefaultDispatcher\n    @Provides\n    fun provideDefaultDispatcher(): CoroutineDispatcher = Dispatchers.Default\n\n    @MainDispatcher\n    @Provides\n    fun provideMainDispatcher(): CoroutineDispatcher = Dispatchers.Main\n}","import dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.components.SingletonComponent\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.Dispatchers\nimport javax.inject.Qualifier","Inject dispatchers for testability. Replace with TestDispatcher in tests.",https://developer.android.com/training/dependency-injection/hilt-android#qualifiers
room_setup,Room Database Setup,Android,Database,"room database dao entity migration","Complete Room setup with Entity DAO and Database","@Entity(tableName = ""items"")\ndata class ItemEntity(\n    @PrimaryKey val id: String,\n    val title: String,\n    val description: String,\n    val imageUrl: String?,\n    val createdAt: Long = System.currentTimeMillis()\n)\n\n@Dao\ninterface ItemDao {\n    @Query(""SELECT * FROM items ORDER BY createdAt DESC"")\n    fun observeAll(): Flow<List<ItemEntity>>\n\n    @Query(""SELECT * FROM items WHERE id = :id"")\n    suspend fun getById(id: String): ItemEntity?\n\n    @Upsert\n    suspend fun upsert(item: ItemEntity)\n\n    @Upsert\n    suspend fun upsertAll(items: List<ItemEntity>)\n\n    @Query(""DELETE FROM items"")\n    suspend fun deleteAll()\n}\n\n@Database(\n    entities = [ItemEntity::class],\n    version = 1,\n    exportSchema = true\n)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun itemDao(): ItemDao\n}","import androidx.room.*\nimport kotlinx.coroutines.flow.Flow","Use @Upsert over @Insert(onConflict=REPLACE). exportSchema=true for migrations.",https://developer.android.com/training/data-storage/room
room_hilt,Room Hilt Module,Android,Database,"room hilt module provides database dao","Hilt module providing Room database and DAOs","@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n    @Provides\n    @Singleton\n    fun provideDatabase(\n        @ApplicationContext context: Context\n    ): AppDatabase = Room.databaseBuilder(\n        context,\n        AppDatabase::class.java,\n        ""app_database""\n    )\n        .fallbackToDestructiveMigration()\n        .build()\n\n    @Provides\n    fun provideItemDao(db: AppDatabase): ItemDao = db.itemDao()\n}","import android.content.Context\nimport androidx.room.Room\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton","Use fallbackToDestructiveMigration only in dev. Write proper migrations for prod.",https://developer.android.com/training/data-storage/room
compose_screen,Compose Screen with ViewModel,Android,Compose,"compose screen viewmodel collectasstate lifecycle","Standard Compose screen consuming ViewModel state","@Composable\nfun HomeScreen(\n    viewModel: HomeViewModel = hiltViewModel(),\n    onItemClick: (String) -> Unit\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    Scaffold(\n        topBar = {\n            TopAppBar(title = { Text(""Home"") })\n        }\n    ) { padding ->\n        when (val state = uiState) {\n            is HomeUiState.Loading -> {\n                Box(Modifier.fillMaxSize().padding(padding), contentAlignment = Alignment.Center) {\n                    CircularProgressIndicator()\n                }\n            }\n            is HomeUiState.Success -> {\n                LazyColumn(\n                    modifier = Modifier.padding(padding),\n                    contentPadding = PaddingValues(16.dp),\n                    verticalArrangement = Arrangement.spacedBy(8.dp)\n                ) {\n                    items(state.items, key = { it.id }) { item ->\n                        ItemCard(item = item, onClick = { onItemClick(item.id) })\n                    }\n                }\n            }\n            is HomeUiState.Error -> {\n                ErrorContent(\n                    message = state.message,\n                    onRetry = viewModel::loadData,\n                    modifier = Modifier.padding(padding)\n                )\n            }\n        }\n    }\n}","import androidx.compose.runtime.getValue\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle","Always use collectAsStateWithLifecycle. Handle all UiState branches.",https://developer.android.com/develop/ui/compose/state
compose_card,Material3 Card Component,Android,Compose,"card material3 compose clickable elevation","Reusable Material3 card composable","@Composable\nfun ItemCard(\n    item: Item,\n    onClick: () -> Unit,\n    modifier: Modifier = Modifier\n) {\n    ElevatedCard(\n        onClick = onClick,\n        modifier = modifier.fillMaxWidth()\n    ) {\n        Row(\n            modifier = Modifier.padding(16.dp),\n            horizontalArrangement = Arrangement.spacedBy(12.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            AsyncImage(\n                model = item.imageUrl,\n                contentDescription = item.title,\n                modifier = Modifier\n                    .size(64.dp)\n                    .clip(RoundedCornerShape(8.dp)),\n                contentScale = ContentScale.Crop\n            )\n            Column(modifier = Modifier.weight(1f)) {\n                Text(\n                    text = item.title,\n                    style = MaterialTheme.typography.titleMedium\n                )\n                Text(\n                    text = item.subtitle,\n                    style = MaterialTheme.typography.bodyMedium,\n                    color = MaterialTheme.colorScheme.onSurfaceVariant\n                )\n            }\n        }\n    }\n}","import androidx.compose.material3.*\nimport coil.compose.AsyncImage","Use ElevatedCard for clickable cards. AsyncImage from Coil for images.",https://developer.android.com/develop/ui/compose/components/card
compose_pullrefresh,Pull to Refresh,Android,Compose,"pulltorefresh swipe refresh loading indicator","Pull-to-refresh with Material3","@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun RefreshableList(\n    items: List<Item>,\n    isRefreshing: Boolean,\n    onRefresh: () -> Unit,\n    modifier: Modifier = Modifier\n) {\n    val pullRefreshState = rememberPullToRefreshState()\n\n    PullToRefreshBox(\n        isRefreshing = isRefreshing,\n        onRefresh = onRefresh,\n        state = pullRefreshState,\n        modifier = modifier\n    ) {\n        LazyColumn(\n            contentPadding = PaddingValues(16.dp),\n            verticalArrangement = Arrangement.spacedBy(8.dp)\n        ) {\n            items(items, key = { it.id }) { item ->\n                ItemCard(item = item)\n            }\n        }\n    }\n}","import androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.pulltorefresh.*","Use Material3 PullToRefreshBox. Pass isRefreshing from ViewModel.",https://developer.android.com/reference/kotlin/androidx/compose/material3/pulltorefresh/package-summary
compose_bottomsheet,Modal Bottom Sheet,Android,Compose,"bottomsheet modal sheet compose material3","Material3 Modal Bottom Sheet","@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun FilterBottomSheet(\n    onDismiss: () -> Unit,\n    onApply: (Filter) -> Unit\n) {\n    val sheetState = rememberModalBottomSheetState()\n\n    ModalBottomSheet(\n        onDismissRequest = onDismiss,\n        sheetState = sheetState\n    ) {\n        Column(\n            modifier = Modifier\n                .padding(horizontal = 16.dp)\n                .padding(bottom = 32.dp),\n            verticalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            Text(\n                text = ""Filters"",\n                style = MaterialTheme.typography.headlineSmall\n            )\n            // Filter options here\n            Button(\n                onClick = { onApply(filter) },\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(""Apply"")\n            }\n        }\n    }\n}","import androidx.compose.material3.*","Add bottom padding for system navigation bar.",https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#ModalBottomSheet
compose_searchbar,Search Bar,Android,Compose,"searchbar search query compose material3 dockedsearchbar","Material3 SearchBar with suggestions","@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun SearchTopBar(\n    query: String,\n    onQueryChange: (String) -> Unit,\n    onSearch: (String) -> Unit,\n    suggestions: List<String>,\n    modifier: Modifier = Modifier\n) {\n    var expanded by rememberSaveable { mutableStateOf(false) }\n\n    SearchBar(\n        inputField = {\n            SearchBarDefaults.InputField(\n                query = query,\n                onQueryChange = onQueryChange,\n                onSearch = {\n                    onSearch(it)\n                    expanded = false\n                },\n                expanded = expanded,\n                onExpandedChange = { expanded = it },\n                placeholder = { Text(""Search..."") },\n                leadingIcon = { Icon(Icons.Default.Search, ""Search"") },\n                trailingIcon = if (query.isNotEmpty()) {\n                    { IconButton(onClick = { onQueryChange("""") }) { Icon(Icons.Default.Clear, ""Clear"") } }\n                } else null\n            )\n        },\n        expanded = expanded,\n        onExpandedChange = { expanded = it },\n        modifier = modifier\n    ) {\n        suggestions.forEach { suggestion ->\n            ListItem(\n                headlineContent = { Text(suggestion) },\n                modifier = Modifier.clickable { onSearch(suggestion); expanded = false }\n            )\n        }\n    }\n}","import androidx.compose.material3.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*","Debounce onQueryChange in ViewModel (300ms).",https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#SearchBar
navigation_setup,Navigation Compose Setup,Android,Navigation,"navigation compose navhost route typesafe","Type-safe Navigation Compose setup with routes","@Serializable data object HomeRoute\n@Serializable data class DetailRoute(val id: String)\n@Serializable data object SettingsRoute\n\n@Composable\nfun AppNavHost(\n    navController: NavHostController = rememberNavController()\n) {\n    NavHost(\n        navController = navController,\n        startDestination = HomeRoute\n    ) {\n        composable<HomeRoute> {\n            HomeScreen(\n                onItemClick = { id -> navController.navigate(DetailRoute(id)) }\n            )\n        }\n        composable<DetailRoute> { backStackEntry ->\n            val route = backStackEntry.toRoute<DetailRoute>()\n            DetailScreen(\n                itemId = route.id,\n                onBack = { navController.popBackStack() }\n            )\n        }\n        composable<SettingsRoute> {\n            SettingsScreen(onBack = { navController.popBackStack() })\n        }\n    }\n}","import androidx.navigation.compose.*\nimport androidx.navigation.toRoute\nimport kotlinx.serialization.Serializable","Use @Serializable data objects for type-safe routes (Navigation 2.8+).",https://developer.android.com/guide/navigation/design/type-safety
navigation_bottombar,Bottom Navigation with NavHost,Android,Navigation,"bottom navigation bar navhost compose scaffold","Bottom navigation with NavHost and selected state","@Serializable data object HomeRoute\n@Serializable data object SearchRoute\n@Serializable data object ProfileRoute\n\ndata class TopLevelRoute(\n    val label: String,\n    val route: Any,\n    val icon: ImageVector,\n    val selectedIcon: ImageVector\n)\n\nval topLevelRoutes = listOf(\n    TopLevelRoute(""Home"", HomeRoute, Icons.Outlined.Home, Icons.Filled.Home),\n    TopLevelRoute(""Search"", SearchRoute, Icons.Outlined.Search, Icons.Filled.Search),\n    TopLevelRoute(""Profile"", ProfileRoute, Icons.Outlined.Person, Icons.Filled.Person)\n)\n\n@Composable\nfun MainScreen() {\n    val navController = rememberNavController()\n    val navBackStackEntry by navController.currentBackStackEntryAsState()\n\n    Scaffold(\n        bottomBar = {\n            NavigationBar {\n                topLevelRoutes.forEach { topRoute ->\n                    val selected = navBackStackEntry?.destination?.hasRoute(topRoute.route::class) == true\n                    NavigationBarItem(\n                        selected = selected,\n                        onClick = {\n                            navController.navigate(topRoute.route) {\n                                popUpTo(navController.graph.findStartDestination().id) { saveState = true }\n                                launchSingleTop = true\n                                restoreState = true\n                            }\n                        },\n                        icon = { Icon(if (selected) topRoute.selectedIcon else topRoute.icon, topRoute.label) },\n                        label = { Text(topRoute.label) }\n                    )\n                }\n            }\n        }\n    ) { padding ->\n        NavHost(navController, startDestination = HomeRoute, Modifier.padding(padding)) {\n            composable<HomeRoute> { HomeScreen() }\n            composable<SearchRoute> { SearchScreen() }\n            composable<ProfileRoute> { ProfileScreen() }\n        }\n    }\n}","import androidx.navigation.compose.*\nimport kotlinx.serialization.Serializable","Save/restore tab state with popUpTo + saveState + restoreState.",https://developer.android.com/develop/ui/compose/components/bottom-navigation
retrofit_api,Retrofit API Interface,Android,Network,"retrofit api interface suspend get post","Retrofit API interface with suspend functions","interface ItemApi {\n    @GET(""items"")\n    suspend fun getItems(\n        @Query(""page"") page: Int = 1,\n        @Query(""limit"") limit: Int = 20\n    ): ItemsResponse\n\n    @GET(""items/{id}"")\n    suspend fun getItem(@Path(""id"") id: String): ItemDto\n\n    @POST(""items"")\n    suspend fun createItem(@Body item: CreateItemRequest): ItemDto\n\n    @PUT(""items/{id}"")\n    suspend fun updateItem(\n        @Path(""id"") id: String,\n        @Body item: UpdateItemRequest\n    ): ItemDto\n\n    @DELETE(""items/{id}"")\n    suspend fun deleteItem(@Path(""id"") id: String)\n\n    @Multipart\n    @POST(""items/{id}/image"")\n    suspend fun uploadImage(\n        @Path(""id"") id: String,\n        @Part image: MultipartBody.Part\n    ): ImageResponse\n}","import retrofit2.http.*\nimport okhttp3.MultipartBody","All functions should be suspend. Use @Query for pagination.",https://square.github.io/retrofit/
retrofit_auth,Auth Interceptor,Android,Network,"interceptor auth token refresh okhttp header","OkHttp interceptor for auth token injection and refresh","class AuthInterceptor @Inject constructor(\n    private val tokenManager: TokenManager\n) : Interceptor {\n    override fun intercept(chain: Interceptor.Chain): Response {\n        val token = tokenManager.getAccessToken()\n        val request = chain.request().newBuilder()\n            .apply { token?.let { header(""Authorization"", ""Bearer $it"") } }\n            .build()\n        return chain.proceed(request)\n    }\n}\n\nclass TokenRefreshAuthenticator @Inject constructor(\n    private val tokenManager: TokenManager,\n    private val authApi: Lazy<AuthApi>\n) : Authenticator {\n    override fun authenticate(route: Route?, response: Response): Request? {\n        if (response.code != 401) return null\n        synchronized(this) {\n            val newToken = runBlocking {\n                tokenManager.refreshToken(authApi.get())\n            } ?: return null\n            return response.request.newBuilder()\n                .header(""Authorization"", ""Bearer $newToken"")\n                .build()\n        }\n    }\n}","import okhttp3.Interceptor\nimport okhttp3.Response\nimport okhttp3.Authenticator","Use Authenticator for 401 refresh. Lazy inject AuthApi to avoid circular deps.",https://square.github.io/okhttp/features/interceptors/
paging_setup,Paging3 Setup,Android,List,"paging3 pagingsource remote mediator lazycolumn","Complete Paging3 setup with PagingSource and LazyColumn","class ItemPagingSource(\n    private val api: ItemApi\n) : PagingSource<Int, Item>() {\n    override fun getRefreshKey(state: PagingState<Int, Item>) =\n        state.anchorPosition?.let { state.closestPageToPosition(it)?.prevKey?.plus(1) }\n\n    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, Item> {\n        val page = params.key ?: 1\n        return try {\n            val response = api.getItems(page = page, limit = params.loadSize)\n            LoadResult.Page(\n                data = response.items.map { it.toDomain() },\n                prevKey = if (page == 1) null else page - 1,\n                nextKey = if (response.items.isEmpty()) null else page + 1\n            )\n        } catch (e: Exception) {\n            LoadResult.Error(e)\n        }\n    }\n}\n\n// In ViewModel:\nval items = Pager(\n    config = PagingConfig(pageSize = 20, prefetchDistance = 5)\n) { ItemPagingSource(api) }.flow.cachedIn(viewModelScope)\n\n// In Composable:\nval lazyPagingItems = viewModel.items.collectAsLazyPagingItems()\nLazyColumn {\n    items(lazyPagingItems.itemCount, key = lazyPagingItems.itemKey { it.id }) { index ->\n        lazyPagingItems[index]?.let { ItemCard(it) }\n    }\n}","import androidx.paging.*\nimport androidx.paging.compose.collectAsLazyPagingItems\nimport androidx.paging.compose.itemKey","Use cachedIn(viewModelScope). Always provide key for LazyColumn.",https://developer.android.com/topic/libraries/architecture/paging/v3-overview
datastore_prefs,DataStore Preferences,Android,Storage,"datastore preferences migration sharedpreferences","DataStore Preferences setup with type-safe keys","class UserPreferences @Inject constructor(\n    @ApplicationContext private val context: Context\n) {\n    private val Context.dataStore by preferencesDataStore(\n        name = ""user_preferences""\n    )\n\n    private object Keys {\n        val DARK_MODE = booleanPreferencesKey(""dark_mode"")\n        val LANGUAGE = stringPreferencesKey(""language"")\n        val ONBOARDING_DONE = booleanPreferencesKey(""onboarding_done"")\n    }\n\n    val darkMode: Flow<Boolean> = context.dataStore.data\n        .map { it[Keys.DARK_MODE] ?: false }\n\n    val language: Flow<String> = context.dataStore.data\n        .map { it[Keys.LANGUAGE] ?: ""en"" }\n\n    suspend fun setDarkMode(enabled: Boolean) {\n        context.dataStore.edit { it[Keys.DARK_MODE] = enabled }\n    }\n\n    suspend fun setLanguage(lang: String) {\n        context.dataStore.edit { it[Keys.LANGUAGE] = lang }\n    }\n}","import androidx.datastore.preferences.core.*\nimport androidx.datastore.preferences.preferencesDataStore\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map","Replace SharedPreferences with DataStore. Expose Flow for reactive reads.",https://developer.android.com/topic/libraries/architecture/datastore
compose_theme,Material3 Theme Setup,Android,Theme,"theme material3 dynamic color typography dark","Complete Material3 theme with dynamic colors","private val DarkColorScheme = darkColorScheme(\n    primary = Color(0xFF90CAF9),\n    secondary = Color(0xFFCE93D8),\n    tertiary = Color(0xFF80CBC4)\n)\n\nprivate val LightColorScheme = lightColorScheme(\n    primary = Color(0xFF1976D2),\n    secondary = Color(0xFF7B1FA2),\n    tertiary = Color(0xFF00897B)\n)\n\n@Composable\nfun AppTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    dynamicColor: Boolean = true,\n    content: @Composable () -> Unit\n) {\n    val colorScheme = when {\n        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n        darkTheme -> DarkColorScheme\n        else -> LightColorScheme\n    }\n\n    MaterialTheme(\n        colorScheme = colorScheme,\n        typography = AppTypography,\n        content = content\n    )\n}","import androidx.compose.material3.*\nimport androidx.compose.foundation.isSystemInDarkTheme","Use dynamic colors on Android 12+. Fallback to custom scheme.",https://developer.android.com/develop/ui/compose/designsystems/material3
compose_empty_error,Empty and Error States,Android,Compose,"empty state error retry illustration placeholder","Reusable empty and error state composables","@Composable\nfun EmptyState(\n    title: String,\n    description: String,\n    icon: ImageVector = Icons.Outlined.Inbox,\n    actionLabel: String? = null,\n    onAction: (() -> Unit)? = null,\n    modifier: Modifier = Modifier\n) {\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(32.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Icon(\n            imageVector = icon,\n            contentDescription = null,\n            modifier = Modifier.size(72.dp),\n            tint = MaterialTheme.colorScheme.onSurfaceVariant\n        )\n        Spacer(Modifier.height(16.dp))\n        Text(title, style = MaterialTheme.typography.titleLarge)\n        Spacer(Modifier.height(8.dp))\n        Text(\n            description,\n            style = MaterialTheme.typography.bodyMedium,\n            color = MaterialTheme.colorScheme.onSurfaceVariant,\n            textAlign = TextAlign.Center\n        )\n        if (actionLabel != null && onAction != null) {\n            Spacer(Modifier.height(24.dp))\n            Button(onClick = onAction) { Text(actionLabel) }\n        }\n    }\n}\n\n@Composable\nfun ErrorContent(\n    message: String,\n    onRetry: () -> Unit,\n    modifier: Modifier = Modifier\n) {\n    EmptyState(\n        title = ""Something went wrong"",\n        description = message,\n        icon = Icons.Outlined.ErrorOutline,\n        actionLabel = ""Retry"",\n        onAction = onRetry,\n        modifier = modifier\n    )\n}","import androidx.compose.material3.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.outlined.*","Always provide Empty and Error states. Never show blank screen.",
compose_shimmer,Shimmer Loading Skeleton,Android,Compose,"shimmer loading skeleton placeholder animation","Shimmer loading animation composable","fun Modifier.shimmerEffect(): Modifier = composed {\n    var size by remember { mutableStateOf(IntSize.Zero) }\n    val transition = rememberInfiniteTransition(label = ""shimmer"")\n    val startOffsetX by transition.animateFloat(\n        initialValue = -2 * size.width.toFloat(),\n        targetValue = 2 * size.width.toFloat(),\n        animationSpec = infiniteRepeatable(tween(1000)),\n        label = ""shimmer""\n    )\n\n    background(\n        brush = Brush.linearGradient(\n            colors = listOf(\n                MaterialTheme.colorScheme.surfaceVariant,\n                MaterialTheme.colorScheme.surface,\n                MaterialTheme.colorScheme.surfaceVariant\n            ),\n            start = Offset(startOffsetX, 0f),\n            end = Offset(startOffsetX + size.width.toFloat(), size.height.toFloat())\n        )\n    ).onGloballyPositioned { size = it.size }\n}\n\n@Composable\nfun ItemCardShimmer(modifier: Modifier = Modifier) {\n    Row(modifier = modifier.padding(16.dp), horizontalArrangement = Arrangement.spacedBy(12.dp)) {\n        Box(Modifier.size(64.dp).clip(RoundedCornerShape(8.dp)).shimmerEffect())\n        Column(Modifier.weight(1f), verticalArrangement = Arrangement.spacedBy(8.dp)) {\n            Box(Modifier.fillMaxWidth(0.7f).height(16.dp).clip(RoundedCornerShape(4.dp)).shimmerEffect())\n            Box(Modifier.fillMaxWidth(0.5f).height(14.dp).clip(RoundedCornerShape(4.dp)).shimmerEffect())\n        }\n    }\n}","import androidx.compose.animation.core.*\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Brush\nimport androidx.compose.ui.unit.IntSize","Use shimmer over CircularProgressIndicator for content loading.",
test_viewmodel,ViewModel Unit Test,Android,Testing,"test viewmodel junit turbine mockk coroutine","Complete ViewModel unit test with Turbine and MockK","@OptIn(ExperimentalCoroutinesApi::class)\nclass HomeViewModelTest {\n\n    @get:Rule\n    val mainDispatcherRule = MainDispatcherRule()\n\n    private val repository: HomeRepository = mockk()\n    private lateinit var viewModel: HomeViewModel\n\n    @Before\n    fun setup() {\n        coEvery { repository.getData() } returns listOf(Item(""1"", ""Test""))\n        viewModel = HomeViewModel(repository)\n    }\n\n    @Test\n    fun `loadData emits Loading then Success`() = runTest {\n        viewModel.uiState.test {\n            assertEquals(HomeUiState.Loading, awaitItem())\n            assertEquals(HomeUiState.Success(listOf(Item(""1"", ""Test""))), awaitItem())\n        }\n    }\n\n    @Test\n    fun `loadData emits Error on failure`() = runTest {\n        coEvery { repository.getData() } throws IOException(""Network error"")\n        viewModel = HomeViewModel(repository)\n\n        viewModel.uiState.test {\n            assertEquals(HomeUiState.Loading, awaitItem())\n            val error = awaitItem()\n            assertTrue(error is HomeUiState.Error)\n        }\n    }\n}\n\nclass MainDispatcherRule(\n    private val dispatcher: TestDispatcher = UnconfinedTestDispatcher()\n) : TestWatcher() {\n    override fun starting(description: Description) {\n        Dispatchers.setMain(dispatcher)\n    }\n    override fun finished(description: Description) {\n        Dispatchers.resetMain()\n    }\n}","import app.cash.turbine.test\nimport io.mockk.coEvery\nimport io.mockk.mockk\nimport kotlinx.coroutines.test.*\nimport org.junit.Rule\nimport org.junit.Test","MainDispatcherRule replaces Main dispatcher. Turbine for Flow testing.",https://developer.android.com/training/testing/local-tests
test_compose,Compose UI Test,Android,Testing,"compose test ui semantics rule click assert","Compose UI test with ComposeTestRule","class HomeScreenTest {\n\n    @get:Rule\n    val composeTestRule = createComposeRule()\n\n    @Test\n    fun showsLoadingIndicator_whenLoading() {\n        composeTestRule.setContent {\n            AppTheme {\n                HomeScreen(uiState = HomeUiState.Loading, onItemClick = {})\n            }\n        }\n        composeTestRule.onNode(hasTestTag(""loading_indicator"")).assertIsDisplayed()\n    }\n\n    @Test\n    fun showsItems_whenSuccess() {\n        val items = listOf(Item(""1"", ""First""), Item(""2"", ""Second""))\n        composeTestRule.setContent {\n            AppTheme {\n                HomeScreen(uiState = HomeUiState.Success(items), onItemClick = {})\n            }\n        }\n        composeTestRule.onNodeWithText(""First"").assertIsDisplayed()\n        composeTestRule.onNodeWithText(""Second"").assertIsDisplayed()\n    }\n\n    @Test\n    fun showsErrorWithRetry_whenError() {\n        composeTestRule.setContent {\n            AppTheme {\n                HomeScreen(uiState = HomeUiState.Error(""Network error""), onItemClick = {})\n            }\n        }\n        composeTestRule.onNodeWithText(""Network error"").assertIsDisplayed()\n        composeTestRule.onNodeWithText(""Retry"").assertIsDisplayed()\n    }\n}","import androidx.compose.ui.test.*\nimport androidx.compose.ui.test.junit4.createComposeRule\nimport org.junit.Rule\nimport org.junit.Test","Test composables by passing UiState directly. Use testTag for finding nodes.",https://developer.android.com/develop/ui/compose/testing
app_class,Hilt Application Class,Android,Setup,"hilt application class entry point android","HiltAndroidApp Application class","@HiltAndroidApp\nclass MyApp : Application()\n\n// In AndroidManifest.xml:\n// <application\n//     android:name="".MyApp""\n//     android:allowBackup=""false""\n//     android:theme=""@style/Theme.MyApp""\n//     tools:targetApi=""31"">\n//     <activity\n//         android:name="".MainActivity""\n//         android:exported=""true"">\n//         <intent-filter>\n//             <action android:name=""android.intent.action.MAIN"" />\n//             <category android:name=""android.intent.category.LAUNCHER"" />\n//         </intent-filter>\n//     </activity>\n// </application>","import android.app.Application\nimport dagger.hilt.android.HiltAndroidApp","@HiltAndroidApp is required. Set allowBackup=false for security.",https://developer.android.com/training/dependency-injection/hilt-android
mainactivity,MainActivity with Compose,Android,Setup,"mainactivity compose setcontent edge edge enableedgetoedge","MainActivity setup with edge-to-edge Compose","@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            AppTheme {\n                AppNavHost()\n            }\n        }\n    }\n}","import android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport dagger.hilt.android.AndroidEntryPoint","enableEdgeToEdge() for modern Android look. @AndroidEntryPoint for Hilt.",https://developer.android.com/develop/ui/compose/setup
domain_model,Domain Model with Mappers,Android,Architecture,"domain model entity dto mapper clean","Domain model with DTO and Entity mappers","// Domain model\ndata class Item(\n    val id: String,\n    val title: String,\n    val description: String,\n    val imageUrl: String?,\n    val price: Double,\n    val isFavorite: Boolean = false\n)\n\n// DTO (from API)\n@JsonClass(generateAdapter = true)\ndata class ItemDto(\n    val id: String,\n    val title: String,\n    val description: String,\n    @Json(name = ""image_url"") val imageUrl: String?,\n    val price: Double\n) {\n    fun toDomain() = Item(id, title, description, imageUrl, price)\n}\n\n// Entity (Room)\n@Entity(tableName = ""items"")\ndata class ItemEntity(\n    @PrimaryKey val id: String,\n    val title: String,\n    val description: String,\n    val imageUrl: String?,\n    val price: Double,\n    val isFavorite: Boolean = false\n) {\n    fun toDomain() = Item(id, title, description, imageUrl, price, isFavorite)\n}\n\nfun Item.toEntity() = ItemEntity(id, title, description, imageUrl, price, isFavorite)","import com.squareup.moshi.Json\nimport com.squareup.moshi.JsonClass\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey","Separate DTO Entity and Domain models. Map at boundaries.",https://developer.android.com/topic/architecture/data-layer
usecase,UseCase Pattern,Android,Architecture,"usecase invoke operator clean domain business logic","Invocable UseCase with operator fun","abstract class UseCase<in P, R> {\n    suspend operator fun invoke(params: P): Result<R> = try {\n        Result.success(execute(params))\n    } catch (e: Exception) {\n        Result.failure(e)\n    }\n    protected abstract suspend fun execute(params: P): R\n}\n\nclass GetItemUseCase @Inject constructor(\n    private val repository: ItemRepository\n) : UseCase<String, Item>() {\n    override suspend fun execute(params: String): Item =\n        repository.getItem(params)\n}\n\nclass GetItemsUseCase @Inject constructor(\n    private val repository: ItemRepository\n) : UseCase<Unit, List<Item>>() {\n    override suspend fun execute(params: Unit): List<Item> =\n        repository.getItems()\n}\n\n// Usage in ViewModel:\nval result = getItemUseCase(itemId)\nresult.fold(\n    onSuccess = { _uiState.value = UiState.Success(it) },\n    onFailure = { _uiState.value = UiState.Error(it.message) }\n)","import javax.inject.Inject","Use operator fun invoke for clean call syntax. Only for non-trivial business logic.",https://developer.android.com/topic/architecture/domain-layer
compose_remember_perf,Remember for Performance,Android,Performance,"compose remember cache expensive calculation sort filter","Optimize expensive calculations with remember","// BAD: Expensive calculation on every recomposition\n@Composable\nfun ContactList(\n    contacts: List<Contact>,\n    comparator: Comparator<Contact>\n) {\n    LazyColumn {\n        // PROBLEM: sorts entire list on EVERY recomposition\n        items(contacts.sortedWith(comparator)) { contact ->\n            ContactCard(contact)\n        }\n    }\n}\n\n// GOOD: Cache calculation with remember\n@Composable\nfun ContactList(\n    contacts: List<Contact>,\n    comparator: Comparator<Contact>\n) {\n    // Only sorts when contacts or comparator changes\n    val sortedContacts = remember(contacts, comparator) {\n        contacts.sortedWith(comparator)\n    }\n    \n    LazyColumn {\n        items(sortedContacts, key = { it.id }) { contact ->\n            ContactCard(contact)\n        }\n    }\n}","import androidx.compose.runtime.remember\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items","Use remember with keys to cache expensive calculations. Only recalculates when dependencies change.",https://developer.android.com/develop/ui/compose/performance/bestpractices
compose_derivedstate,DerivedStateOf for Scroll,Android,Performance,"derivedstateof scroll performance recomposition limit","Limit recompositions with derivedStateOf","// BAD: Recomposes on every scroll pixel\n@Composable\nfun ScrollableListWithButton() {\n    val listState = rememberLazyListState()\n    \n    LazyColumn(state = listState) {\n        // ...\n    }\n    \n    // PROBLEM: firstVisibleItemIndex changes constantly during scroll\n    // causing AnimatedVisibility to recompose on every pixel\n    val showButton = listState.firstVisibleItemIndex > 0\n    \n    AnimatedVisibility(visible = showButton) {\n        ScrollToTopButton()\n    }\n}\n\n// GOOD: Use derivedStateOf to reduce recomposition\n@Composable\nfun ScrollableListWithButton() {\n    val listState = rememberLazyListState()\n    \n    LazyColumn(state = listState) {\n        // ...\n    }\n    \n    // Only recomposes when the boolean value actually changes\n    val showButton by remember {\n        derivedStateOf {\n            listState.firstVisibleItemIndex > 0\n        }\n    }\n    \n    AnimatedVisibility(visible = showButton) {\n        ScrollToTopButton()\n    }\n}","import androidx.compose.runtime.derivedStateOf\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.foundation.lazy.rememberLazyListState","Use derivedStateOf when derived value changes less frequently than source state.",https://developer.android.com/develop/ui/compose/performance/bestpractices
compose_lazy_keys,Lazy Layout Stable Keys,Android,Performance,"lazycolumn lazyrow item key stable reorder","Provide stable keys for lazy layouts","// BAD: No keys - full recomposition on reorder\n@Composable\nfun NotesList(notes: List<Note>) {\n    LazyColumn {\n        // PROBLEM: When a note moves (e.g. sorted by time)\n        // Compose thinks all items changed and recomposes everything\n        items(notes) { note ->\n            NoteRow(note)\n        }\n    }\n}\n\n// GOOD: Stable keys enable smart recomposition\n@Composable\nfun NotesList(notes: List<Note>) {\n    LazyColumn {\n        // With key, Compose knows which item is which\n        // Only the moved item updates, others skip recomposition\n        items(\n            items = notes,\n            key = { note -> note.id }\n        ) { note ->\n            NoteRow(note)\n        }\n    }\n}\n\n// ALSO GOOD: Using itemsIndexed with key\n@Composable\nfun NotesList(notes: List<Note>) {\n    LazyColumn {\n        itemsIndexed(\n            items = notes,\n            key = { _, note -> note.id }\n        ) { index, note ->\n            NoteRow(note, index)\n        }\n    }\n}","import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.foundation.lazy.itemsIndexed","Always provide stable unique keys for list items to optimize recomposition.",https://developer.android.com/develop/ui/compose/performance/bestpractices
compose_defer_reads,Defer State Reads,Android,Performance,"defer lambda state read recomposition scope offset","Defer state reads to narrow recomposition scope","// BAD: State read in parent causes wide recomposition\n@Composable\nfun SnackDetail() {\n    val scroll = rememberScrollState(0)\n    \n    Box(Modifier.fillMaxSize()) {\n        // PROBLEM: Reading scroll.value here means the entire\n        // Box recomposes on every scroll change\n        Title(snack, scroll.value)\n        // ...\n    }\n}\n\n@Composable\nfun Title(snack: Snack, scroll: Int) {\n    val offset = with(LocalDensity.current) { scroll.toDp() }\n    Column(modifier = Modifier.offset(y = offset)) {\n        Text(snack.name)\n    }\n}\n\n// BETTER: Pass state as lambda to defer read\n@Composable\nfun SnackDetail() {\n    val scroll = rememberScrollState(0)\n    \n    Box(Modifier.fillMaxSize()) {\n        // Pass lambda - read happens in Title, not here\n        Title(snack, scrollProvider = { scroll.value })\n        // ...\n    }\n}\n\n@Composable\nfun Title(snack: Snack, scrollProvider: () -> Int) {\n    val offset = with(LocalDensity.current) { \n        scrollProvider().toDp() \n    }\n    Column(modifier = Modifier.offset(y = offset)) {\n        Text(snack.name)\n    }\n}\n\n// BEST: Use Modifier lambda to skip recomposition entirely\n@Composable\nfun SnackDetail() {\n    val scroll = rememberScrollState(0)\n    \n    Box(Modifier.fillMaxSize()) {\n        Title(snack, scrollProvider = { scroll.value })\n        // ...\n    }\n}\n\n@Composable\nfun Title(snack: Snack, scrollProvider: () -> Int) {\n    // Layout phase only - no recomposition!\n    Column(\n        modifier = Modifier.offset {\n            IntOffset(x = 0, y = scrollProvider())\n        }\n    ) {\n        Text(snack.name)\n    }\n}","import androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.IntOffset\nimport androidx.compose.foundation.rememberScrollState","Pass state as lambdas to defer reads. Use Modifier lambdas for layout-only changes.",https://developer.android.com/develop/ui/compose/performance/bestpractices
compose_backwards_write,Avoid Backwards Writes,Android,Performance,"backwards write infinite loop state recomposition","Never write to state after reading it","// BAD: Backwards write causes infinite recomposition\n@Composable\nfun BadComposable() {\n    var count by remember { mutableStateOf(0) }\n    \n    // User clicks button\n    Button(onClick = { count++ }) {\n        Text(\"Recompose\")\n    }\n    \n    // Read state\n    Text(\"Count: $count\")\n    \n    // PROBLEM: Writing to state AFTER reading it\n    // This causes another recomposition, which reads count,\n    // then writes again, infinite loop!\n    count++  // BACKWARDS WRITE - DON'T DO THIS\n}\n\n// GOOD: Only write state in event handlers\n@Composable\nfun GoodComposable() {\n    var count by remember { mutableStateOf(0) }\n    \n    // State writes ONLY happen in response to events\n    Button(onClick = { count++ }) {\n        Text(\"Increment\")\n    }\n    \n    Button(onClick = { count = 0 }) {\n        Text(\"Reset\")\n    }\n    \n    // Only read state for display\n    Text(\"Count: $count\")\n    \n    // No writes in composition body\n}\n\n// GOOD: Use LaunchedEffect for side effects\n@Composable\nfun TimerComposable() {\n    var count by remember { mutableStateOf(0) }\n    \n    // Side effects in LaunchedEffect, not composition\n    LaunchedEffect(Unit) {\n        while (true) {\n            delay(1000)\n            count++\n        }\n    }\n    \n    Text(\"Seconds: $count\")\n}","import androidx.compose.runtime.*\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.Text\nimport kotlinx.coroutines.delay","Never write to state in composition body after reading it. Use event handlers or LaunchedEffect.",https://developer.android.com/develop/ui/compose/performance/bestpractices
